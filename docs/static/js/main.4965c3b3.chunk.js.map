{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["WIDTH","HEIGHT","directions","INSTRUCTIONS","MAX_INSTRUCTION_COUNT","initializeProgram","Array","from","length","WHITE","undefined","BLACK","initializeProgramState","instruction","count","x","Math","floor","y","grid","initializePossibleActions","possibleActions","direction","color","push","program","programState","previousGrids","previousGridsColors","split","map","d","context","INSTRUCTIONS_EXHAUSTED","App","props","start","setState","intervalHandle","setInterval","steps","stop","nextFn","state","clearInterval","nsteps","changedCells","stopped","instructionsExhausted","i","stepResult","step","cell","k","colorToWrite","fillStyle","fillRect","setTimeout","nextProgram","currentColor","action","actionIndex","random","createAction","nextX","nextY","nextInstruction","previousGrid","gridScore","score","computeScore","better","console","log","JSON","stringify","splice","unshift","group","hexdigits","gidx","groupEnd","gridIdx","canvas","document","querySelector","getContext","this","className","id","width","height","disabled","onClick","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.4965c3b3.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./App.css\";\n\nconst RANDOM = true;\nconst WIDTH = 601;\nconst HEIGHT = 601;\nconst CELL_SIZE = 1;\n\nconst directions = [\n  [-1, 0], // right\n  [0, 1], // down\n  [1, 0], // left\n  [0, -1], // up\n];\n\nconst BLANK = 0;\nconst WHITE = 1;\nconst BLACK = 2;\n\nconst RIGHT = 0;\nconst DOWN = 1;\nconst LEFT = 2;\nconst UP = 3;\n\nlet INSTRUCTIONS = 100;\nconst MAX_INSTRUCTION_COUNT = 100000;\nconst PAUSE = 1;\n\nconst initializeProgram = () =>\n  Array.from({ length: INSTRUCTIONS }, () => ({\n    WHITE: undefined,\n    BLACK: undefined,\n  }));\n\nconst initializeProgramState = () => ({\n  instruction: 0,\n  count: 0,\n  x: Math.floor(WIDTH / 2) + 1,\n  y: Math.floor(HEIGHT / 2) + 1,\n  grid: Array.from({ length: WIDTH }, () =>\n    Array.from({ length: HEIGHT }, () => BLANK)\n  ),\n});\n\nlet actionChoices = [];\nlet currentActionChoice = null;\n\nconst initializePossibleActions = () => {\n  const possibleActions = [];\n  for (const direction of [RIGHT, DOWN, LEFT, UP]) {\n    for (const color of [BLACK, WHITE]) {\n      for (let instruction = 0; instruction < INSTRUCTIONS; ++instruction) {\n        possibleActions.push({ direction, color, instruction });\n      }\n    }\n  }\n  actionChoices = [];\n  currentActionChoice = null;\n  return possibleActions;\n};\n\nlet program = initializeProgram();\nlet programState = initializeProgramState();\n\nlet possibleActions = initializePossibleActions();\n\nconst previousGrids = [];\nconst previousGridsColors = \"123456789ABCDEF\"\n  .split(\"\")\n  .map((d) => `#${d}${d}${d}${d}${d}${d}`);\nlet context = null;\n\nconst INSTRUCTIONS_EXHAUSTED = \"INSTRUCTIONS_EXHAUSTED\";\n\n// This creates an action, reusing the choices done by the previous program\nconst createAction = () => {\n  if (RANDOM) {\n    const actionIndex = Math.floor(Math.random() * possibleActions.length);\n    const action = possibleActions[actionIndex];\n    return action;\n  }\n  // TODO: handle boundary when everything is maxxed\n  if (currentActionChoice === null) {\n    currentActionChoice = 0;\n  }\n  if (actionChoices[currentActionChoice] === undefined) {\n    actionChoices.push(0);\n  } else {\n    // we increment this action choice only in all the next action choices are maxxed\n    let maxxed = true;\n    console.log(actionChoices);\n    if (currentActionChoice < actionChoices.length - 1) {\n      for (let i = currentActionChoice + 1; i < actionChoices.length; ++i) {\n        if (actionChoices[i] !== possibleActions.length - 1) {\n          maxxed = false;\n        }\n      }\n    } else {\n      if (actionChoices[currentActionChoice] !== possibleActions.length - 1) {\n        maxxed = false;\n      }\n    }\n    if (maxxed) {\n      if (currentActionChoice === 0) {\n        return INSTRUCTIONS_EXHAUSTED;\n      } else {\n        ++actionChoices[currentActionChoice];\n        actionChoices.splice(currentActionChoice + 1);\n      }\n    } else {\n      ++actionChoices[currentActionChoice];\n    }\n  }\n  const action = possibleActions[actionChoices[currentActionChoice]];\n  ++currentActionChoice;\n  return action;\n};\n\nconst computeScore = (grid, count) => {\n  let score = 0;\n  for (let x = 0; x < WIDTH; ++x) {\n    for (let y = 0; y < HEIGHT; ++y) {\n      if (grid[x][y] !== 0) {\n        ++score;\n      }\n    }\n  }\n  score += 1 - count / MAX_INSTRUCTION_COUNT;\n  return score;\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { intervalHandle: null };\n  }\n  start = () => {\n    this.setState({ intervalHandle: setInterval(() => this.steps(1000), 1) });\n  };\n  stop = (nextFn) => {\n    const { intervalHandle } = this.state;\n    clearInterval(intervalHandle);\n    this.setState({ intervalHandle: null }, nextFn);\n  };\n  steps = (nsteps) => {\n    let changedCells = {};\n    let stopped = false;\n    let instructionsExhausted = false;\n    for (let i = 0; i < nsteps; ++i) {\n      const stepResult = this.step();\n      if (stepResult.cell) {\n        changedCells[`${stepResult.cell.x}-${stepResult.cell.y}`] =\n          stepResult.cell;\n      }\n      if (stepResult.stopped) {\n        stopped = true;\n        instructionsExhausted = stepResult.instructionsExhausted;\n        break;\n      }\n    }\n    for (const k in changedCells) {\n      const x = changedCells[k].x;\n      const y = changedCells[k].y;\n      const colorToWrite = changedCells[k].colorToWrite;\n      context.fillStyle = colorToWrite === BLACK ? \"black\" : \"white\";\n      context.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);\n    }\n    if (stopped) {\n      this.stop(() => {\n        setTimeout(() => {\n          this.nextProgram(instructionsExhausted);\n          this.start();\n        }, PAUSE);\n      });\n    }\n  };\n  step = () => {\n    const { instruction, x, y, grid } = programState;\n    let currentColor = grid[x][y];\n    if (currentColor === BLANK) {\n      currentColor = WHITE;\n    }\n    let action = program[instruction][currentColor];\n    if (action === undefined) {\n      action = createAction();\n      program[instruction][currentColor] = action;\n    }\n    if (action === INSTRUCTIONS_EXHAUSTED) {\n      return { stopped: true, cell: null, instructionsExhausted: true };\n    }\n    const nextX = x + directions[action.direction][0];\n    const nextY = y + directions[action.direction][1];\n    if (\n      nextX < 0 ||\n      nextX >= WIDTH ||\n      nextY < 0 ||\n      nextY >= HEIGHT ||\n      programState.count > MAX_INSTRUCTION_COUNT\n    ) {\n      return { stopped: true, cell: null, instructionsExhausted: false };\n    }\n    const nextInstruction = action.instruction;\n    const colorToWrite = action.color;\n    grid[x][y] = action.color;\n    programState.x = nextX;\n    programState.y = nextY;\n    programState.instruction = nextInstruction;\n    ++programState.count;\n    return {\n      cell: { x, y, colorToWrite },\n      stopped: false,\n      instructionsExhausted: false,\n    };\n  };\n  nextProgram = (instructionsExhausted) => {\n    const previousGrid = programState.grid;\n    const gridScore = computeScore(previousGrid, programState.count);\n    let better = false;\n    if (previousGrids.length === 0) {\n      better = true;\n    } else {\n      for (const previousGrid of previousGrids) {\n        if (previousGrid.score < gridScore) {\n          better = true;\n        }\n      }\n    }\n    if (better) {\n      console.log(JSON.stringify(program, null, 2));\n      if (previousGrids.length === previousGridsColors.length) {\n        previousGrids.splice(previousGrids.length - 1);\n      }\n      previousGrids.unshift({ grid: previousGrid, score: gridScore });\n      console.log(\"High scores\");\n      console.group();\n      const hexdigits = \"123456789ABCDEF\".split(\"\");\n      for (let gidx = 0; gidx < previousGrids.length; ++gidx) {\n        console.log(`${hexdigits[gidx]} - ${previousGrids[gidx].score}`);\n      }\n      console.groupEnd();\n    }\n    context.fillStyle = \"white\";\n    context.fillRect(0, 0, WIDTH * CELL_SIZE, HEIGHT * CELL_SIZE);\n    for (let gridIdx = previousGrids.length - 1; gridIdx >= 0; --gridIdx) {\n      const grid = previousGrids[gridIdx].grid;\n      const color = previousGridsColors[gridIdx];\n      context.fillStyle = color;\n      for (let x = 0; x < WIDTH; ++x) {\n        for (let y = 0; y < HEIGHT; ++y) {\n          if (grid[x][y]) {\n            context.fillRect(\n              x * CELL_SIZE,\n              y * CELL_SIZE,\n              CELL_SIZE,\n              CELL_SIZE\n            );\n          }\n        }\n      }\n    }\n    if (instructionsExhausted) {\n      ++INSTRUCTIONS;\n      console.log(\n        \"Switching to program with \" + INSTRUCTIONS + \" instructions\"\n      );\n      possibleActions = initializePossibleActions();\n    }\n\n    program = initializeProgram();\n    programState = initializeProgramState();\n    currentActionChoice = 0;\n  };\n  componentDidMount() {\n    const canvas = document.querySelector(\"#canvas\");\n    context = canvas.getContext(\"2d\");\n  }\n  render() {\n    const { intervalHandle } = this.state;\n    return (\n      <div className=\"App\">\n        <p>\n          This is 2D Black and White Turing Machine simulator on a non-toroidal\n          grid\n        </p>\n        <p>\n          It randomly generates 2D Turing programs by choosing a random action\n          among the possible actions every time the machine does not know what\n          to do.\n        </p>\n        <p>Max number of instructions: {INSTRUCTIONS}</p>\n        <p>Max computation horizon: {MAX_INSTRUCTION_COUNT}</p>\n        <p>\n          Score: number of cells written on the grid, and speed at which these\n          cells were written in the fractional part\n        </p>\n        <p>\n          The last best computation shadows are displayed in shades of gray.\n        </p>\n        <p>\n          If you find a 2D Turing machine that grows in the center and gradually\n          fills the space, without going to the infinite left, right, top or\n          bottom, that would be a good one.\n        </p>\n        <p>Some info is dumped in the developer console</p>\n        <div>\n          <canvas\n            id=\"canvas\"\n            width={WIDTH * CELL_SIZE}\n            height={HEIGHT * CELL_SIZE}\n          />\n        </div>\n        <div>\n          <button disabled={!!intervalHandle} onClick={this.start}>\n            Start\n          </button>\n          <button disabled={!intervalHandle} onClick={() => this.stop()}>\n            Stop\n          </button>\n          <button disabled={!!intervalHandle} onClick={this.nextProgram}>\n            Next\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}