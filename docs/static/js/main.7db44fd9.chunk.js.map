{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["directions","initializeProgram","instructions","Array","from","length","WHITE","undefined","BLACK","getDimensions","gridSize","width","height","initializeProgramState","numberOfOuterWalls","grid","color","pristine","widx","x","y","instruction","count","actionChoices","currentActionChoice","initializePossibleActions","randomize","possibleActions","direction","push","randomized","idx","Math","floor","random","splice","console","log","JSON","stringify","colorLetters","directionLetters","program","programState","previousGrids","previousGridsColors","split","map","d","INSTRUCTIONS_EXHAUSTED","App","props","start","isFreshStart","state","cellSize","increaseSpeed","instructionsSteps","randomizePossibleActions","context","getContext","fillStyle","fillRect","setState","intervalHandle","setInterval","currentSpeed","steps","stop","nextFn","pauseHandle","clearInterval","clearTimeout","nsteps","pauseDuration","changedCells","stopped","instructionsExhausted","i","stepResult","step","cell","k","colorToWrite","setTimeout","pauseHande","nextProgram","generateRandomActions","maxInstructionCount","currentColor","action","actionIndex","maxxed","createAction","nextX","nextY","awesome","nextInstruction","historyLength","previousGrid","gridScore","score","computeScore","better","str","sep","programToString","unshift","sort","g1","g2","min","group","hexdigits","gidx","groupEnd","gridIdx","skipToNext","bestNotGood","pop","document","querySelector","this","running","className","htmlFor","name","type","value","disabled","onChange","e","Number","target","checked","max","onClick","id","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.7db44fd9.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./App.css\";\n\nconst directions = [\n  [-1, 0], // right\n  [0, 1], // down\n  [1, 0], // left\n  [0, -1], // up\n];\n\nconst WHITE = 0;\nconst BLACK = 1;\n\nconst RIGHT = 0;\nconst DOWN = 1;\nconst LEFT = 2;\nconst UP = 3;\n\nconst initializeProgram = (instructions) =>\n  Array.from({ length: instructions }, () => ({\n    WHITE: undefined,\n    BLACK: undefined,\n  }));\n\nconst getDimensions = (gridSize) => ({\n  width: gridSize * 2 + 1,\n  height: gridSize * 2 + 1,\n});\n\nconst initializeProgramState = (gridSize, numberOfOuterWalls) => {\n  const { width, height } = getDimensions(gridSize);\n  const grid = Array.from({ length: width }, () =>\n    Array.from({ length: height }, () => ({ color: WHITE, pristine: true }))\n  );\n  for (let widx = 0; widx < numberOfOuterWalls; ++widx) {\n    // north and south\n    for (let x = 2 * widx; x < width - 2 * widx; ++x) {\n      grid[x][2 * widx].color = BLACK;\n      grid[x][height - 1 - 2 * widx].color = BLACK;\n    }\n    // east and west\n    for (let y = 2 * widx; y < height - 2 * widx; ++y) {\n      grid[2 * widx][y].color = BLACK;\n      grid[width - 1 - 2 * widx][y].color = BLACK;\n    }\n  }\n  return {\n    instruction: 0,\n    count: 0,\n    x: gridSize + 1,\n    y: gridSize + 1,\n    grid,\n  };\n};\n\nlet actionChoices = [];\nlet currentActionChoice = 0;\n\nconst initializePossibleActions = (instructions, randomize) => {\n  let possibleActions = [];\n  for (const direction of [RIGHT, DOWN, LEFT, UP]) {\n    for (const color of [BLACK, WHITE]) {\n      for (let instruction = 0; instruction < instructions; ++instruction) {\n        possibleActions.push({ direction, color, instruction });\n      }\n    }\n  }\n  if (randomize) {\n    const randomized = [];\n    while (possibleActions.length > 0) {\n      const idx = Math.floor(Math.random() * possibleActions.length);\n      randomized.push(possibleActions[idx]);\n      possibleActions.splice(idx, 1);\n    }\n    possibleActions = randomized;\n    console.log(\"Randomized possible actions:\");\n    console.log(JSON.stringify(possibleActions));\n  }\n  return possibleActions;\n};\n\nconst colorLetters = [\"W\", \"B\"];\nconst directionLetters = [\"ðŸ ž\", \"ðŸ Ÿ\", \"ðŸ œ\", \"ðŸ \"];\n\nconst programToString = (program) => {\n  let str = \"\";\n  let sep = false;\n  for (let i = 0; i < program.length; ++i) {\n    for (const color of [WHITE, BLACK]) {\n      if (sep) {\n        str += \",\";\n      }\n      if (program[i]) {\n        const action = program[i][color];\n        if (action) {\n          str += i;\n          str += colorLetters[color];\n          str += directionLetters[action.direction];\n          str += colorLetters[action.color];\n          str += action.instruction;\n          sep = true;\n        } else {\n          sep = false;\n        }\n      }\n    }\n  }\n  return str;\n};\n\nlet program = null;\nlet programState = null;\nlet possibleActions = null;\n\nconst previousGrids = [];\nconst previousGridsColors = \"123456789ABCDEF\"\n  .split(\"\")\n  .map((d) => `#${d}${d}${d}${d}${d}${d}`);\n\nconst INSTRUCTIONS_EXHAUSTED = \"INSTRUCTIONS_EXHAUSTED\";\n\nconst createAction = (random) => {\n  if (random) {\n    const actionIndex = Math.floor(Math.random() * possibleActions.length);\n    const action = possibleActions[actionIndex];\n    return action;\n  }\n  if (actionChoices[currentActionChoice] === undefined) {\n    actionChoices[currentActionChoice] = 0;\n  } else {\n    // if all next actions are maxxed, increase this one and remove the remaining actions\n    let maxxed = true;\n    for (let i = currentActionChoice + 1; i < actionChoices.length; ++i) {\n      if (actionChoices[i] !== possibleActions.length - 1) {\n        maxxed = false;\n      }\n    }\n    if (maxxed) {\n      if (\n        currentActionChoice === 0 &&\n        actionChoices[currentActionChoice] === possibleActions.length - 1\n      ) {\n        return INSTRUCTIONS_EXHAUSTED;\n      } else {\n        ++actionChoices[currentActionChoice];\n        actionChoices.splice(currentActionChoice + 1);\n      }\n    }\n  }\n  const action = possibleActions[actionChoices[currentActionChoice]];\n  ++currentActionChoice;\n  return action;\n};\n\nconst computeScore = (grid, count, width, height, maxInstructionCount) => {\n  let score = 0;\n  for (let x = 0; x < width; ++x) {\n    for (let y = 0; y < height; ++y) {\n      if (!grid[x][y].pristine) {\n        ++score;\n      }\n    }\n  }\n  score += 1 - count / maxInstructionCount;\n  return score;\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      intervalHandle: null,\n      pauseHandle: null,\n      instructions: 10,\n      instructionsSteps: 1,\n      maxInstructionCount: 1_000_000,\n      pauseDuration: 1,\n      gridSize: 150,\n      cellSize: 2,\n      generateRandomActions: false,\n      numberOfOuterWalls: 0,\n      context: null,\n      increaseSpeed: true,\n      currentSpeed: null,\n      historyLength: 1,\n      randomizePossibleActions: true,\n      awesome: false,\n    };\n  }\n  start = (isFreshStart) => {\n    const {\n      gridSize,\n      instructions,\n      numberOfOuterWalls,\n      cellSize,\n      increaseSpeed,\n      instructionsSteps,\n      randomizePossibleActions,\n    } = this.state;\n\n    const { width, height } = getDimensions(gridSize);\n    program = initializeProgram(instructions);\n    programState = initializeProgramState(gridSize, numberOfOuterWalls);\n    if (isFreshStart) {\n      possibleActions = initializePossibleActions(\n        instructions,\n        randomizePossibleActions\n      );\n    }\n    const context = this.getContext();\n    context.fillStyle = \"darkgray\";\n    for (let x = 0; x < width; ++x) {\n      for (let y = 0; y < height; ++y) {\n        if (programState.grid[x][y].color === BLACK) {\n          context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n        }\n      }\n    }\n\n    this.setState({\n      context,\n      intervalHandle: setInterval(() => {\n        const { currentSpeed } = this.state;\n        this.setState(\n          {\n            currentSpeed:\n              currentSpeed === null\n                ? instructionsSteps\n                : increaseSpeed\n                ? currentSpeed + 1\n                : currentSpeed,\n          },\n          () => {\n            const { currentSpeed } = this.state;\n            this.steps(currentSpeed);\n          }\n        );\n      }, 1),\n    });\n  };\n  stop = (nextFn) => {\n    const { intervalHandle, pauseHandle } = this.state;\n    clearInterval(intervalHandle);\n    clearTimeout(pauseHandle);\n    this.setState({ intervalHandle: null, pauseHandle: null }, nextFn);\n  };\n  steps = (nsteps) => {\n    const { cellSize, pauseDuration, context } = this.state;\n    let changedCells = {};\n    let stopped = false;\n    let instructionsExhausted = false;\n    for (let i = 0; i < nsteps; ++i) {\n      const stepResult = this.step();\n      if (stepResult.cell) {\n        changedCells[`${stepResult.cell.x}-${stepResult.cell.y}`] =\n          stepResult.cell;\n      }\n      if (stepResult.stopped) {\n        stopped = true;\n        instructionsExhausted = stepResult.instructionsExhausted;\n        break;\n      }\n    }\n    for (const k in changedCells) {\n      const x = changedCells[k].x;\n      const y = changedCells[k].y;\n      const colorToWrite = changedCells[k].colorToWrite;\n      context.fillStyle = colorToWrite === BLACK ? \"black\" : \"white\";\n      context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n    }\n    if (stopped) {\n      this.stop(() => {\n        this.setState({\n          pauseHandle: setTimeout(() => {\n            this.setState({ pauseHande: null }, () => {\n              this.nextProgram(instructionsExhausted);\n              this.start(false);\n            });\n          }, pauseDuration),\n        });\n      });\n    }\n  };\n  step = () => {\n    const { generateRandomActions, gridSize, maxInstructionCount } = this.state;\n    const { instruction, x, y, grid } = programState;\n    const { width, height } = getDimensions(gridSize);\n    let currentColor = grid[x][y].color;\n    let action = program[instruction][currentColor];\n    if (action === undefined) {\n      action = createAction(generateRandomActions);\n      program[instruction][currentColor] = action;\n    }\n    if (action === INSTRUCTIONS_EXHAUSTED) {\n      return { stopped: true, cell: null, instructionsExhausted: true };\n    }\n    const nextX = x + directions[action.direction][0];\n    const nextY = y + directions[action.direction][1];\n    if (\n      nextX < 0 ||\n      nextX >= width ||\n      nextY < 0 ||\n      nextY >= height ||\n      (programState.count > maxInstructionCount && !this.state.awesome)\n    ) {\n      return { stopped: true, cell: null, instructionsExhausted: false };\n    }\n    const nextInstruction = action.instruction;\n    const colorToWrite = action.color;\n    grid[x][y].color = colorToWrite;\n    grid[x][y].pristine = false;\n    programState.x = nextX;\n    programState.y = nextY;\n    programState.instruction = nextInstruction;\n    ++programState.count;\n    return {\n      cell: { x, y, colorToWrite },\n      stopped: false,\n      instructionsExhausted: false,\n    };\n  };\n  nextProgram = (instructionsExhausted) => {\n    const {\n      gridSize,\n      cellSize,\n      instructions,\n      maxInstructionCount,\n      numberOfOuterWalls,\n      context,\n      instructionsSteps,\n      historyLength,\n    } = this.state;\n    console.log(JSON.stringify(actionChoices));\n    const { width, height } = getDimensions(gridSize);\n    const previousGrid = programState.grid;\n    const gridScore = computeScore(\n      previousGrid,\n      programState.count,\n      width,\n      height,\n      maxInstructionCount\n    );\n    let better = false;\n    if (previousGrids.length === 0) {\n      better = true;\n    } else {\n      for (const previousGrid of previousGrids) {\n        if (previousGrid.score < gridScore) {\n          better = true;\n        }\n      }\n    }\n    if (better) {\n      console.log(programToString(program));\n      previousGrids.unshift({ grid: previousGrid, score: gridScore });\n      previousGrids.sort((g1, g2) => {\n        if (g1.score === g2.score) {\n          return 0;\n        } else {\n          return g1.score < g2.score ? 1 : -1;\n        }\n      });\n\n      if (\n        previousGrids.length >\n        Math.min(historyLength, previousGridsColors.length)\n      ) {\n        previousGrids.splice(previousGrids.length - 1);\n      }\n      console.log(\"High scores\");\n      console.group();\n      const hexdigits = \"123456789ABCDEF\".split(\"\");\n      for (let gidx = 0; gidx < previousGrids.length; ++gidx) {\n        console.log(`${hexdigits[gidx]} - ${previousGrids[gidx].score}`);\n      }\n      console.groupEnd();\n    }\n    context.fillStyle = \"#EEEEEE\";\n    context.fillRect(0, 0, width * cellSize, height * cellSize);\n    for (let gridIdx = previousGrids.length - 1; gridIdx >= 0; --gridIdx) {\n      const grid = previousGrids[gridIdx].grid;\n      const color = previousGridsColors[gridIdx];\n\n      context.fillStyle = color;\n      if (previousGrids.length === 1) {\n        context.fillStyle = \"red\";\n      }\n      for (let x = 0; x < width; ++x) {\n        for (let y = 0; y < height; ++y) {\n          if (previousGrids.length === 1) {\n            if (grid[x][y].color === BLACK) {\n              context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n            }\n          } else {\n            if (!grid[x][y].pristine) {\n              context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n            }\n          }\n        }\n      }\n    }\n    if (instructionsExhausted) {\n      console.log(\n        \"Switching to program with \" + (instructions + 1) + \" instructions\"\n      );\n      this.setState(\n        { instructions: instructions + 1, currentSpeed: instructionsSteps },\n        () => {\n          const {\n            instructions,\n            gridSize,\n            numberOfOuterWalls,\n            randomizePossibleActions,\n          } = this.state;\n          possibleActions = initializePossibleActions(\n            instructions,\n            randomizePossibleActions\n          );\n          program = initializeProgram(instructions);\n          programState = initializeProgramState(gridSize, numberOfOuterWalls);\n          actionChoices.splice(currentActionChoice);\n          currentActionChoice = 0;\n        }\n      );\n    } else {\n      this.setState({ currentSpeed: instructionsSteps }, () => {\n        program = initializeProgram(instructions);\n        programState = initializeProgramState(gridSize, numberOfOuterWalls);\n        actionChoices.splice(currentActionChoice);\n        currentActionChoice = 0;\n      });\n    }\n  };\n  getContext() {\n    const canvas = document.querySelector(\"#canvas\");\n    return canvas.getContext(\"2d\");\n  }\n  skipToNext = () => {\n    const { maxInstructionCount } = this.state;\n    programState.count += maxInstructionCount;\n  };\n  bestNotGood = () => {\n    if (previousGrids.length > 0) {\n      previousGrids.pop();\n    }\n  };\n  awesome = () => {\n    this.setState({ awesome: !this.state.awesome });\n  };\n  render() {\n    const {\n      intervalHandle,\n      pauseHandle,\n      instructions,\n      instructionsSteps,\n      maxInstructionCount,\n      pauseDuration,\n      gridSize,\n      cellSize,\n      generateRandomActions,\n      numberOfOuterWalls,\n      increaseSpeed,\n      currentSpeed,\n      historyLength,\n      randomizePossibleActions,\n    } = this.state;\n    const running = intervalHandle !== null || pauseHandle !== null;\n    const { width, height } = getDimensions(gridSize);\n    return (\n      <div className=\"App\">\n        <div>\n          <label htmlFor=\"instructions\">Number of instructions</label>\n          <input\n            min={1}\n            name=\"instructions\"\n            type=\"number\"\n            value={instructions}\n            disabled={running}\n            onChange={(e) =>\n              this.setState({ instructions: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <label htmlFor=\"maxInstructionCount\">Max instruction count</label>\n          <input\n            min={1}\n            name=\"maxInstructionCount\"\n            type=\"number\"\n            value={maxInstructionCount}\n            disabled={running}\n            onChange={(e) =>\n              this.setState({ maxInstructionCount: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <label htmlFor=\"instructionsSteps\">Instructions per step</label>\n          <input\n            min={1}\n            name=\"instructionsSteps\"\n            type=\"number\"\n            value={instructionsSteps}\n            disabled={running}\n            onChange={(e) =>\n              this.setState({ instructionsSteps: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <input\n            type=\"checkbox\"\n            name=\"increaseSpeed\"\n            checked={increaseSpeed}\n            onChange={(e) => this.setState({ increaseSpeed: e.target.checked })}\n          />\n          <label htmlFor=\"increaseSpeed\">Increase speed</label>\n        </div>\n        <div>\n          <label htmlFor=\"pauseDuration\">Pause between runs</label>\n          <input\n            min={1}\n            name=\"pauseDuration\"\n            type=\"number\"\n            value={pauseDuration}\n            disabled={running}\n            onChange={(e) =>\n              this.setState({ pauseDuration: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <label htmlFor=\"gridSize\">Grid size</label>\n          <input\n            min={0}\n            name=\"gridSize\"\n            type=\"number\"\n            value={gridSize}\n            disabled={running}\n            onChange={(e) =>\n              this.setState({ gridSize: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <label htmlFor=\"cellSize\">Cell size</label>\n          <input\n            min={0}\n            name=\"cellSize\"\n            type=\"number\"\n            value={cellSize}\n            disabled={running}\n            onChange={(e) =>\n              this.setState({ cellSize: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <input\n            type=\"checkbox\"\n            name=\"generateRandomActions\"\n            checked={generateRandomActions}\n            onChange={(e) =>\n              this.setState({ generateRandomActions: e.target.checked })\n            }\n          />\n          <label htmlFor=\"generateRandomActions\">Generate random actions</label>\n        </div>\n        <div>\n          <input\n            type=\"checkbox\"\n            name=\"randomizePossibleActions\"\n            checked={randomizePossibleActions}\n            onChange={(e) =>\n              this.setState({ randomizePossibleActions: e.target.checked })\n            }\n          />\n          <label htmlFor=\"randomizePossibleActions\">\n            Randomize possible actions\n          </label>\n        </div>\n        <div>\n          <label htmlFor=\"numberOfOuterWalls\">Number of outer walls</label>\n          <input\n            min={0}\n            name=\"numberOfOuterWalls\"\n            type=\"number\"\n            value={numberOfOuterWalls}\n            disabled={running}\n            onChange={(e) =>\n              this.setState({ numberOfOuterWalls: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <label htmlFor=\"historyLength\">History length</label>\n          <input\n            name=\"historyLength\"\n            type=\"number\"\n            value={historyLength}\n            disabled={running}\n            max={previousGridsColors.length}\n            min={0}\n            onChange={(e) =>\n              this.setState({ historyLength: Number(e.target.value) })\n            }\n          />\n        </div>\n        <div>\n          <button disabled={running} onClick={() => this.start(true)}>\n            Start\n          </button>\n          <button disabled={!running} onClick={() => this.stop()}>\n            Stop\n          </button>\n          <button disabled={!running} onClick={() => this.skipToNext()}>\n            Skip to next\n          </button>\n          <button onClick={() => this.bestNotGood()}>Best is not good</button>\n          <button onClick={() => this.awesome()}>\n            Awesome{this.state.awesome ? \" !\" : \"\"}\n          </button>\n        </div>\n        <div>Current speed: {currentSpeed}</div>\n        <div>Current count: {programState?.count}</div>\n        <div>\n          <canvas\n            id=\"canvas\"\n            width={width * cellSize}\n            height={height * cellSize}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}