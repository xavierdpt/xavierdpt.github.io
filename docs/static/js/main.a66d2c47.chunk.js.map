{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["WIDTH","HEIGHT","directions","initializeProgram","Array","from","length","WHITE","undefined","BLACK","initializeProgramState","instruction","count","x","Math","floor","y","grid","program","programState","possibleActions","direction","color","push","actionChoices","currentActionChoice","context","App","props","start","setState","intervalHandle","setInterval","step","stop","nextFn","state","clearInterval","currentColor","reRender","action","maxxed","i","splice","createAction","nextX","nextY","console","log","nextProgram","nextInstruction","colorToWrite","fillStyle","fillRect","forceUpdate","canvas","document","querySelector","getContext","this","className","id","width","height","disabled","onClick","JSON","stringify","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"kLA6CA,I,8FA1CMA,EAAQ,IACRC,EAAS,IAGTC,EAAa,CACjB,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,CAAC,GAAI,IAcDC,EAAoB,kBACxBC,MAAMC,KAAKD,MAAM,CAAEE,OAJA,KAIyB,iBAAO,CACjDC,WAAOC,EACPC,WAAOD,OAGLE,EAAyB,iBAAO,CACpCC,YAAa,EACbC,MAAO,EACPC,EAAGC,KAAKC,MAAMf,OAAa,EAC3BgB,EAAGF,KAAKC,MAAMd,OAAc,EAC5BgB,KAAMb,MAAMC,KAAK,CAAEC,OAAQN,IAAS,kBAClCI,MAAMC,KAAK,CAAEC,OAAQL,IAAU,kBAAM,UAIrCiB,EAAUf,IACVgB,EAAeT,IAEbU,EAAkB,GACxB,MAAwB,CA5BV,EACD,EACA,EACF,GAyBX,eACE,IADG,IAAMC,EAAS,KAClB,MAAoB,CA/BR,EADA,GAgCZ,eACE,IADG,IAAMC,EAAK,KACLX,EAAc,EAAGA,EAzBT,IAyBuCA,EACtDS,EAAgBG,KAAK,CAAEF,YAAWC,QAAOX,gBAI/C,IAAMa,EAAgB,GAClBC,EAAsB,KAEtBC,EAAU,KA4HCC,E,kDA/Fb,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IAGRC,MAAQ,WACN,EAAKC,SAAS,CAAEC,eAAgBC,YAAY,EAAKC,KAAM,MALtC,EAOnBC,KAAO,SAACC,GACN,IAAQJ,EAAmB,EAAKK,MAAxBL,eACRM,cAAcN,GACd,EAAKD,SAAS,CAAEC,eAAgB,MAAQI,IAVvB,EAYnBF,KAAO,WACL,MAAoCd,EAA5BR,EAAR,EAAQA,YAAaE,EAArB,EAAqBA,EAAGG,EAAxB,EAAwBA,EAAGC,EAA3B,EAA2BA,KACrBqB,EAAerB,EAAKJ,GAAGG,GACzBuB,GAAW,EACXC,EAAStB,EAAQP,GAAa2B,GAClC,QAAe9B,IAAXgC,EAAsB,CAGwB,IAAD,EAA/C,GAFAA,EA5Ce,WAKnB,GAH4B,OAAxBf,IACFA,EAAsB,QAEmBjB,IAAvCgB,EAAcC,GAChBD,EAAcD,KAAK,OACd,CAGL,IADA,IAAIkB,GAAS,EACJC,EAAIjB,EAAsB,EAAGiB,EAAIlB,EAAclB,SAAUoC,EAC5DlB,EAAckB,KAAOtB,EAAgBd,OAAS,IAChDmC,GAAS,GAGTA,MACAjB,EAAcC,GAChBD,EAAcmB,OAAOlB,EAAsB,IAG/C,IAAMe,EAASpB,EAAgBI,EAAcC,IAE7C,QADEA,EACKe,EAsBMI,GACT1B,EAAQP,GAAa2B,GAAgBE,OACDhC,IAAhCU,EAAQsB,EAAO7B,aACjBO,EAAQK,MAAR,mBA3FM,OA2FkBf,GAAxB,cA1FM,OA0FsCA,GAA5C,IAEF+B,GAAW,EAEb,IAAMM,EAAQhC,EAAIX,EAAWsC,EAAOnB,WAAW,GACzCyB,EAAQ9B,EAAId,EAAWsC,EAAOnB,WAAW,GAC/C,GACEwB,EAAQ,GACRA,GAAS7C,GACT8C,EAAQ,GACRA,GAAS7C,GACTkB,EAAaP,MA7FW,IAoGxB,OALAmC,QAAQC,IAAI,SAAW7B,EAAaP,MAAQ,UAC5C,EAAKsB,MAAK,WACR,EAAKe,cACL,EAAKpB,WAIT,IAAMqB,EAAkBV,EAAO7B,YACzBwC,EAAeX,EAAOlB,MAC5BI,EAAQ0B,UAjHE,IAiHUD,EAAyB,QAAU,QACvDzB,EAAQ2B,SA3HM,EA2HGxC,EA3HH,EA2HkBG,EA3HlB,KA4HdC,EAAKJ,GAAGG,GAAKwB,EAAOlB,MACpBH,EAAaN,EAAIgC,EACjB1B,EAAaH,EAAI8B,EACjB3B,EAAaR,YAAcuC,IACzB/B,EAAaP,MACX2B,GACF,EAAKe,eAnDU,EAsDnBL,YAAc,WACZF,QAAQC,IAAI,QACZtB,EAAQ0B,UAAY,QACpB1B,EAAQ2B,SAAS,EAAG,EAAGrD,IAAmBC,KAC1CiB,EAAUf,IACVgB,EAAeT,IACfe,EAAsB,GA1DtB,EAAKW,MAAQ,CAAEL,eAAgB,MAFd,E,qDA8DnB,WACE,IAAMwB,EAASC,SAASC,cAAc,WACtC/B,EAAU6B,EAAOG,WAAW,Q,oBAE9B,WAAU,IAAD,OACC3B,EAAmB4B,KAAKvB,MAAxBL,eACR,OACE,sBAAK6B,UAAU,MAAf,UACE,0CACA,8BACE,wBACEC,GAAG,SACHC,MAAO9D,IACP+D,OAAQ9D,QAGZ,gCACE,wBAAQ+D,WAAYjC,EAAgBkC,QAASN,KAAK9B,MAAlD,yBAGA,wBAAQmC,UAAWjC,EAAgBkC,QAAS,kBAAM,EAAK/B,QAAvD,kBAGA,wBAAQ8B,WAAYjC,EAAgBkC,QAASN,KAAKV,YAAlD,kBAGA,8BAAMiB,KAAKC,UAAU,CAAEjD,UAASM,iBAAiB,KAAM,e,GAzF/C4C,IAAMC,WCvETC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFzB,SAAS0B,eAAe,SAM1BZ,M","file":"static/js/main.a66d2c47.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./App.css\";\n\nconst WIDTH = 401;\nconst HEIGHT = 401;\nconst CELL_SIZE = 2;\n\nconst directions = [\n  [-1, 0], // right\n  [0, 1], // down\n  [-1, 0], // left\n  [0, -1], // up\n];\n\nconst WHITE = 0;\nconst BLACK = 1;\n\nconst RIGHT = 0;\nconst DOWN = 1;\nconst LEFT = 2;\nconst UP = 3;\n\nconst INSTRUCTIONS = 5;\nconst MAX_INSTRUCTION_COUNT = 1000;\n\nconst initializeProgram = () =>\n  Array.from(Array({ length: INSTRUCTIONS }), () => ({\n    WHITE: undefined,\n    BLACK: undefined,\n  }));\n\nconst initializeProgramState = () => ({\n  instruction: 0,\n  count: 0,\n  x: Math.floor(WIDTH / 2) + 1,\n  y: Math.floor(HEIGHT / 2) + 1,\n  grid: Array.from({ length: WIDTH }, () =>\n    Array.from({ length: HEIGHT }, () => 0)\n  ),\n});\n\nlet program = initializeProgram();\nlet programState = initializeProgramState();\n\nconst possibleActions = [];\nfor (const direction of [RIGHT, DOWN, LEFT, UP]) {\n  for (const color of [BLACK, WHITE]) {\n    for (let instruction = 0; instruction < INSTRUCTIONS; ++instruction) {\n      possibleActions.push({ direction, color, instruction });\n    }\n  }\n}\nconst actionChoices = [];\nlet currentActionChoice = null;\n\nlet context = null;\n\n// This creates an action, reusing the choices done by the previous program\nconst createAction = () => {\n  // TODO: handle boundary when everything is maxxed\n  if (currentActionChoice === null) {\n    currentActionChoice = 0;\n  }\n  if (actionChoices[currentActionChoice] === undefined) {\n    actionChoices.push(0);\n  } else {\n    // we increment this action choice only in all the next action choices are maxxed\n    let maxxed = true;\n    for (let i = currentActionChoice + 1; i < actionChoices.length; ++i) {\n      if (actionChoices[i] !== possibleActions.length - 1) {\n        maxxed = false;\n      }\n    }\n    if (maxxed) {\n      ++actionChoices[currentActionChoice];\n      actionChoices.splice(currentActionChoice + 1);\n    }\n  }\n  const action = possibleActions[actionChoices[currentActionChoice]];\n  ++currentActionChoice;\n  return action;\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { intervalHandle: null };\n  }\n  start = () => {\n    this.setState({ intervalHandle: setInterval(this.step, 1) });\n  };\n  stop = (nextFn) => {\n    const { intervalHandle } = this.state;\n    clearInterval(intervalHandle);\n    this.setState({ intervalHandle: null }, nextFn);\n  };\n  step = () => {\n    const { instruction, x, y, grid } = programState;\n    const currentColor = grid[x][y];\n    let reRender = false;\n    let action = program[instruction][currentColor];\n    if (action === undefined) {\n      action = createAction();\n      program[instruction][currentColor] = action;\n      if (program[action.instruction] === undefined) {\n        program.push({ [WHITE]: undefined, [BLACK]: undefined });\n      }\n      reRender = true;\n    }\n    const nextX = x + directions[action.direction][0];\n    const nextY = y + directions[action.direction][1];\n    if (\n      nextX < 0 ||\n      nextX >= WIDTH ||\n      nextY < 0 ||\n      nextY >= HEIGHT ||\n      programState.count > MAX_INSTRUCTION_COUNT\n    ) {\n      console.log(\"Stop (\" + programState.count + \")\");\n      this.stop(() => {\n        this.nextProgram();\n        this.start();\n      });\n      return;\n    }\n    const nextInstruction = action.instruction;\n    const colorToWrite = action.color;\n    context.fillStyle = colorToWrite === WHITE ? \"white\" : \"black\";\n    context.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);\n    grid[x][y] = action.color;\n    programState.x = nextX;\n    programState.y = nextY;\n    programState.instruction = nextInstruction;\n    ++programState.count;\n    if (reRender) {\n      this.forceUpdate();\n    }\n  };\n  nextProgram = () => {\n    console.log(\"Next\");\n    context.fillStyle = \"white\";\n    context.fillRect(0, 0, WIDTH * CELL_SIZE, HEIGHT * CELL_SIZE);\n    program = initializeProgram();\n    programState = initializeProgramState();\n    currentActionChoice = 0;\n  };\n  componentDidMount() {\n    const canvas = document.querySelector(\"#canvas\");\n    context = canvas.getContext(\"2d\");\n  }\n  render() {\n    const { intervalHandle } = this.state;\n    return (\n      <div className=\"App\">\n        <div>Welcome</div>\n        <div>\n          <canvas\n            id=\"canvas\"\n            width={WIDTH * CELL_SIZE}\n            height={HEIGHT * CELL_SIZE}\n          />\n        </div>\n        <div>\n          <button disabled={!!intervalHandle} onClick={this.start}>\n            Draw canvas\n          </button>\n          <button disabled={!intervalHandle} onClick={() => this.stop()}>\n            Stop\n          </button>\n          <button disabled={!!intervalHandle} onClick={this.nextProgram}>\n            Next\n          </button>\n          <pre>{JSON.stringify({ program, actionChoices }, null, 2)}</pre>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}