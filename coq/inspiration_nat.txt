
(* This list contains some theorems that are not been mapped to NN yet *)
(*
add_dichotomy: forall n m : nat, (exists p : nat, p + n = m) \/ (exists p : nat, p + m = n)
add_le_cases: forall n m p q : nat, n + m <= p + q -> n <= p \/ m <= q
add_le_lt_mono: forall n m p q : nat, n <= m -> p < q -> n + p < m + q
add_le_mono: forall n m p q : nat, n <= m -> p <= q -> n + p <= m + q
add_le_mono_l: forall n m p : nat, n <= m <-> p + n <= p + m
add_le_mono_r: forall n m p : nat, n <= m <-> n + p <= m + p
add_le_mul: forall a b : nat, 1 < a -> 1 < b -> a + b <= a * b
add_lt_cases: forall n m p q : nat, n + m < p + q -> n < p \/ m < q
add_lt_le_mono: forall n m p q : nat, n < m -> p <= q -> n + p < m + q
add_lt_mono: forall n m p q : nat, n < m -> p < q -> n + p < m + q
add_lt_mono_l: forall n m p : nat, n < m <-> p + n < p + m
add_lt_mono_r: forall n m p : nat, n < m <-> n + p < m + p
add_max_distr_l: forall n m p : nat, Nat.max (p + n) (p + m) = p + Nat.max n m
add_max_distr_r: forall n m p : nat, Nat.max (n + p) (m + p) = Nat.max n m + p
add_min_distr_l: forall n m p : nat, Nat.min (p + n) (p + m) = p + Nat.min n m
add_min_distr_r: forall n m p : nat, Nat.min (n + p) (m + p) = Nat.min n m + p
add_neg_cases: forall n m : nat, n + m < 0 -> n < 0 \/ m < 0
add_nonneg_cases: forall n m : nat, 0 <= n + m -> 0 <= n \/ 0 <= m
add_nonneg_nonneg: forall n m : nat, 0 <= n -> 0 <= m -> 0 <= n + m
add_nonneg_pos: forall n m : nat, 0 <= n -> 0 < m -> 0 < n + m
add_nonpos_cases: forall n m : nat, n + m <= 0 -> n <= 0 \/ m <= 0
add_pos_cases: forall n m : nat, 0 < n + m -> 0 < n \/ 0 < m
add_pos_l: forall n m : nat, 0 < n -> 0 < n + m
add_pos_nonneg: forall n m : nat, 0 < n -> 0 <= m -> 0 < n + m
add_pos_pos: forall n m : nat, 0 < n -> 0 < m -> 0 < n + m
add_pos_r: forall n m : nat, 0 < m -> 0 < n + m
add_succ_comm: forall n m : nat, S n + m = n + S m
add_succ_l: forall n m : nat, S n + m = S (n + m)
add_succ_r: forall n m : nat, n + S m = S (n + m)
eq_0_gt_0_cases: forall n : nat, n = 0 \/ 0 < n
eq_add_0: forall n m : nat, n + m = 0 <-> n = 0 /\ m = 0
eq_add_1: forall n m : nat, n + m = 1 -> n = 1 /\ m = 0 \/ n = 0 /\ m = 1
eq_add_S: forall n m : nat, S n = S m -> n = m
fact_le: forall n m : nat, n <= m -> fact n <= fact m
fact_neq_0: forall n : nat, fact n <> 0
gt_0_eq: forall n : nat, n > 0 \/ 0 = n
gt_asym: forall n m : nat, n > m -> ~ m > n
gt_dec: forall n m : nat, {n > m} + {~ n > m}
gt_eq_gt_dec: forall n m : nat, {m > n} + {n = m} + {n > m}
gt_irrefl: forall n : nat, ~ n > n
gt_le_S: forall n m : nat, m > n -> S n <= m
gt_le_trans: forall n m p : nat, n > m -> p <= m -> n > p
gt_n_S: forall n m : nat, n > m -> S n > S m
gt_not_le: forall n m : nat, n > m -> ~ n <= m
gt_pred: forall n m : nat, m > S n -> Init.Nat.pred m > n
gt_S: forall n m : nat, S n > m -> n > m \/ m = n
gt_S_le: forall n m : nat, S m > n -> n <= m
gt_S_n: forall n m : nat, S m > S n -> m > n
gt_Sn_n: forall n : nat, S n > n
gt_Sn_O: forall n : nat, S n > 0
gt_trans: forall n m p : nat, n > m -> m > p -> n > p
gt_trans_S: forall n m p : nat, S n > m -> m > p -> n > p
le_0_l: forall n : nat, 0 <= n
le_0_n: forall n : nat, 0 <= n
le_0_r: forall n : nat, n <= 0 <-> n = 0
le_1_r: forall n : nat, n <= 1 <-> n = 0 \/ n = 1
le_add_r: forall n m : nat, n <= n + m
le_alt_dichotomy: forall n m : nat, Nat.le_alt n m \/ Nat.le_alt m n
le_antisymm: forall n m : nat, n <= m -> m <= n -> n = m
le_dec: forall n m : nat, {n <= m} + {~ n <= m}
le_decidable: forall n m : nat, Decidable.decidable (n <= m)
le_div2: forall n : nat, Nat.div2 (S n) <= n
le_dne: forall n m : nat, ~ ~ n <= m <-> n <= m
le_elim_rel: forall P : nat -> nat -> Prop, (forall p : nat, P 0 p) -> (forall p q : nat, p <= q -> P p q -> P (S p) (S q)) -> forall n m : nat, n <= m -> P n m
le_equiv: forall n m : nat, Nat.le_alt n m <-> n <= m
le_exists_sub: forall n m : nat, n <= m -> exists p : nat, m = p + n /\ 0 <= p
le_ge_cases: forall n m : nat, n <= m \/ m <= n
le_ge_dec: forall n m : nat, {n <= m} + {n >= m}
le_gt_cases: forall n m : nat, n <= m \/ m < n
le_gt_dec: forall n m : nat, {n <= m} + {n > m}
le_gt_S: forall n m : nat, n <= m -> S m > n
le_gt_trans: forall n m p : nat, m <= n -> m > p -> n > p
le_ind: forall (n : nat) (P : nat -> Prop), P n -> (forall m : nat, n <= m -> P m -> P (S m)) -> forall n0 : nat, n <= n0 -> P n0
le_ind: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall n : nat, A n -> (forall m : nat, n <= m -> A m -> A (S m)) -> forall m : nat, n <= m -> A m
le_ind_rel: forall R : Relation_Definitions.relation nat, Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff)) R -> (forall m : nat, R 0 m) -> (forall n m : nat, n <= m -> R n m -> R (S n) (S m)) -> forall n m : nat, n <= m -> R n m
le_le_add_le: forall n m p q : nat, n <= m -> p + m <= q + n -> p <= q
le_le_pred: forall n m : nat, n <= m -> Nat.pred n <= m
le_le_S_dec: forall n m : nat, {n <= m} + {S m <= n}
le_le_succ_r: forall n m : nat, n <= m -> n <= S m
le_log2_log2_up: forall a : nat, Nat.log2 a <= Nat.log2_up a
le_log2_up_succ_log2: forall a : nat, Nat.log2_up a <= S (Nat.log2 a)
le_lt_add_lt: forall n m p q : nat, n <= m -> p + m < q + n -> p < q
le_lt_dec: forall n m : nat, {n <= m} + {m < n}
le_lt_eq_dec: forall n m : nat, n <= m -> {n < m} + {n = m}
le_lt_n_Sm: forall n m : nat, n <= m -> n < S m
le_lt_or_eq: forall n m : nat, n <= m -> n < m \/ n = m
le_lt_trans: forall n m p : nat, n <= m -> m < p -> n < p
le_lteq: forall n m : nat, n <= m <-> n < m \/ n = m
le_max_l: forall n m : nat, n <= Nat.max n m
le_max_r: forall n m : nat, m <= Nat.max n m
le_min_l: forall n m : nat, Nat.min n m <= n
le_min_r: forall n m : nat, Nat.min n m <= m
le_n: forall n : nat, n <= n
le_n_0_eq: forall n : nat, n <= 0 -> 0 = n
le_n_S: forall n m : nat, n <= m -> S n <= S m
le_n_S: forall n m : nat, n <= m -> S n <= S m
le_neq: forall n m : nat, n < m <-> n <= m /\ n <> m
le_ngt: forall n m : nat, n <= m <-> ~ m < n
le_not_gt: forall n m : nat, n <= m -> ~ n > m
le_not_lt: forall n m : nat, n <= m -> ~ m < n
le_plus_l: forall n m : nat, n <= n + m
le_plus_minus: forall n m : nat, n <= m -> m = n + (m - n)
le_plus_minus_r: forall n m : nat, n <= m -> n + (m - n) = m
le_plus_r: forall n m : nat, m <= n + m
le_plus_trans: forall n m p : nat, n <= m -> n <= m + p
le_Pmult_nat: forall (p : BinNums.positive) (n : nat), n <= BinPos.Pos.iter_op Init.Nat.add p n
le_pred: forall n m : nat, n <= m -> Init.Nat.pred n <= Init.Nat.pred m
le_pred_l: forall n : nat, Nat.pred n <= n
le_pred_le: forall n m : nat, n <= Nat.pred m -> n <= m
le_pred_le_succ: forall n m : nat, Nat.pred n <= m <-> n <= S m
le_refl: forall n : nat, n <= n
le_S: forall n m : nat, n <= m -> n <= S m
le_S_gt: forall n m : nat, S n <= m -> m > n
le_S_n: forall n m : nat, S n <= S m -> n <= m
le_S_n: forall n m : nat, S n <= S m -> n <= m
le_sind: forall (n : nat) (P : nat -> SProp), P n -> (forall m : nat, n <= m -> P m -> P (S m)) -> forall n0 : nat, n <= n0 -> P n0
le_Sn_le: forall n m : nat, S n <= m -> n <= m
le_sqrt_sqrt_up: forall a : nat, Nat.sqrt a <= Nat.sqrt_up a
le_sqrt_up_succ_sqrt: forall a : nat, Nat.sqrt_up a <= S (Nat.sqrt a)
le_stepl: forall x y z : nat, x <= y -> x = z -> z <= y
le_stepr: forall x y z : nat, x <= y -> y = z -> x <= z
le_sub_l: forall n m : nat, n - m <= n
le_sub_le_add_l: forall n m p : nat, n - m <= p <-> n <= m + p
le_sub_le_add_r: forall n m p : nat, n - p <= m <-> n <= m + p
le_succ_diag_r: forall n : nat, n <= S n
le_succ_l: forall n m : nat, S n <= m <-> n < m
le_succ_le_pred: forall n m : nat, S n <= m -> n <= Nat.pred m
le_succ_r: forall n m : nat, n <= S m <-> n <= m \/ n = S m
le_trans: forall n m p : nat, n <= m -> m <= p -> n <= p
le_unique: forall (m n : nat) (le_mn1 le_mn2 : m <= n), le_mn1 = le_mn2
lt_0_mul': forall n m : nat, 0 < n * m <-> 0 < n /\ 0 < m
lt_0_mul: forall n m : nat, 0 < n * m <-> 0 < n /\ 0 < m \/ m < 0 /\ n < 0
lt_0_neq: forall n : nat, 0 < n -> 0 <> n
lt_0_succ: forall n : nat, 0 < S n
lt_1_l': forall n m p : nat, n < m -> m < p -> 1 < p
lt_1_l: forall n m : nat, 0 < n -> n < m -> 1 < m
lt_1_mul_pos: forall n m : nat, 1 < n -> 0 < m -> 1 < n * m
lt_1_r: forall n : nat, n < 1 <-> n = 0
lt_add_lt_sub_l: forall n m p : nat, n + p < m <-> p < m - n
lt_add_lt_sub_r: forall n m p : nat, n + p < m <-> n < m - p
lt_add_pos_l: forall n m : nat, 0 < n -> m < n + m
lt_add_pos_r: forall n m : nat, 0 < n -> m < m + n
lt_asymm: forall n m : nat, n < m -> ~ m < n
lt_dec: forall n m : nat, {n < m} + {~ n < m}
lt_decidable: forall n m : nat, Decidable.decidable (n < m)
lt_div2: forall n : nat, 0 < n -> Nat.div2 n < n
lt_dne: forall n m : nat, ~ ~ n < m <-> n < m
lt_eq_cases: forall n m : nat, n <= m <-> n < m \/ n = m
lt_eq_lt_dec: forall n m : nat, {n < m} + {n = m} + {m < n}
lt_equiv: forall n m : nat, Nat.lt_alt n m <-> n < m
lt_exists_pred: forall z n : nat, z < n -> exists k : nat, n = S k /\ z <= k
lt_exists_pred_strong: forall z n m : nat, z < m -> m <= n -> exists k : nat, m = S k /\ z <= k
lt_ge_cases: forall n m : nat, n < m \/ m <= n
lt_gt_cases: forall n m : nat, n <> m <-> n < m \/ m < n
lt_ind: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall n : nat, A (S n) -> (forall m : nat, n < m -> A m -> A (S m)) -> forall m : nat, n < m -> A m
lt_ind_rel: forall R : Relation_Definitions.relation nat, Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff)) R -> (forall m : nat, R 0 (S m)) -> (forall n m : nat, n < m -> R n m -> R (S n) (S m)) -> forall n m : nat, n < m -> R n m
lt_irrefl: forall x : nat, ~ x < x
lt_le_add_lt: forall n m p q : nat, n < m -> p + m <= q + n -> p < q
lt_le_incl: forall n m : nat, n < m -> n <= m
lt_le_pred: forall n m : nat, n < m -> n <= Nat.pred m
lt_le_S: forall n m : nat, n < m -> S n <= m
lt_le_trans: forall n m p : nat, n < m -> m <= p -> n < p
lt_lt_0: forall n m : nat, n < m -> 0 < m
lt_lt_add_l: forall n m p : nat, n < m -> n < p + m
lt_lt_add_r: forall n m p : nat, n < m -> n < m + p
lt_lt_pred: forall n m : nat, n < m -> Nat.pred n < m
lt_lt_succ_r: forall n m : nat, n < m -> n < S m
lt_n_S: forall n m : nat, n < m -> S n < S m
lt_n_Sm_le: forall n m : nat, n < S m -> n <= m
lt_neq: forall n m : nat, n < m -> n <> m
lt_nge: forall n m : nat, n < m <-> ~ m <= n
lt_not_le: forall n m : nat, n < m -> ~ m <= n
lt_O_fact: forall n : nat, 0 < fact n
lt_O_minus_lt: forall n m : nat, 0 < n - m -> m < n
lt_plus_trans: forall n m p : nat, n < m -> n < m + p
lt_pred: forall n m : nat, S n < m -> n < Init.Nat.pred m
lt_pred_l: forall n : nat, n <> 0 -> Nat.pred n < n
lt_pred_le: forall n m : nat, Nat.pred n < m -> n <= m
lt_pred_lt: forall n m : nat, n < Nat.pred m -> n < m
lt_pred_lt_succ: forall n m : nat, Nat.pred n < m -> n < S m
lt_pred_n_n: forall n : nat, 0 < n -> Init.Nat.pred n < n
lt_S_n: forall n m : nat, S n < S m -> n < m
lt_stepl: forall x y z : nat, x < y -> x = z -> z < y
lt_stepr: forall x y z : nat, x < y -> y = z -> x < z
lt_sub_lt_add_l: forall n m p : nat, n - m < p -> n < m + p
lt_sub_lt_add_r: forall n m p : nat, n - p < m -> n < m + p
lt_succ_diag_r: forall n : nat, n < S n
lt_succ_l: forall n m : nat, S n < m -> n < m
lt_succ_lt_pred: forall n m : nat, S n < m <-> n < Nat.pred m
lt_succ_pred: forall z n : nat, z < n -> S (Nat.pred n) = n
lt_succ_r: forall n m : nat, n < S m <-> n <= m
lt_total: forall n m : nat, n < m \/ n = m \/ m < n
lt_trans: forall n m p : nat, n < m -> m < p -> n < p
lt_trichotomy: forall n m : nat, n < m \/ n = m \/ m < n
max_0_l: forall n : nat, Nat.max 0 n = n
max_0_r: forall n : nat, Nat.max n 0 = n
max_assoc: forall m n p : nat, Nat.max m (Nat.max n p) = Nat.max (Nat.max m n) p
max_case: forall (n m : nat) (P : nat -> Type), P n -> P m -> P (Nat.max n m)
max_case_strong: forall (n m : nat) (P : nat -> Type), (m <= n -> P n) -> (n <= m -> P m) -> P (Nat.max n m)
max_comm: forall n m : nat, Nat.max n m = Nat.max m n
max_dec: forall n m : nat, {Nat.max n m = n} + {Nat.max n m = m}
max_id: forall n : nat, Nat.max n n = n
max_l: forall n m : nat, m <= n -> Init.Nat.max n m = n
max_l: forall n m : nat, m <= n -> Nat.max n m = n
max_l_iff: forall n m : nat, Nat.max n m = n <-> m <= n
max_le: forall n m p : nat, p <= Nat.max n m -> p <= n \/ p <= m
max_le_compat: forall n m p q : nat, n <= m -> p <= q -> Nat.max n p <= Nat.max m q
max_le_compat_l: forall n m p : nat, n <= m -> Nat.max p n <= Nat.max p m
max_le_compat_r: forall n m p : nat, n <= m -> Nat.max n p <= Nat.max m p
max_le_iff: forall n m p : nat, p <= Nat.max n m <-> p <= n \/ p <= m
max_lt_iff: forall n m p : nat, p < Nat.max n m <-> p < n \/ p < m
max_lub: forall n m p : nat, n <= p -> m <= p -> Nat.max n m <= p
max_lub_iff: forall n m p : nat, Nat.max n m <= p <-> n <= p /\ m <= p
max_lub_l: forall n m p : nat, Nat.max n m <= p -> n <= p
max_lub_lt: forall n m p : nat, n < p -> m < p -> Nat.max n m < p
max_lub_lt_iff: forall n m p : nat, Nat.max n m < p <-> n < p /\ m < p
max_lub_r: forall n m p : nat, Nat.max n m <= p -> m <= p
max_min_absorption: forall n m : nat, Nat.min n (Nat.max n m) = n
max_min_antimono: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful eq eq) f -> Morphisms.Proper (Morphisms.respectful le (Basics.flip le)) f -> forall x y : nat, Nat.max (f x) (f y) = f (Nat.min x y)
max_min_antimonotone: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful le (Basics.flip le)) f -> forall x y : nat, Nat.max (f x) (f y) = f (Nat.min x y)
max_min_disassoc: forall n m p : nat, Nat.min n (Nat.max m p) <= Nat.max (Nat.min n m) p
max_min_distr: forall n m p : nat, Nat.max n (Nat.min m p) = Nat.min (Nat.max n m) (Nat.max n p)
max_min_modular: forall n m p : nat, Nat.max n (Nat.min m (Nat.max n p)) = Nat.min (Nat.max n m) (Nat.max n p)
max_mono: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful eq eq) f -> Morphisms.Proper (Morphisms.respectful le le) f -> forall x y : nat, Nat.max (f x) (f y) = f (Nat.max x y)
max_monotone: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful le le) f -> forall x y : nat, Nat.max (f x) (f y) = f (Nat.max x y)
max_r: forall n m : nat, n <= m -> Init.Nat.max n m = m
max_r: forall n m : nat, n <= m -> Nat.max n m = m
max_r_iff: forall n m : nat, Nat.max n m = m <-> n <= m
max_spec: forall n m : nat, n < m /\ Nat.max n m = m \/ m <= n /\ Nat.max n m = n
max_spec_le: forall n m : nat, n <= m /\ Nat.max n m = m \/ m <= n /\ Nat.max n m = n
max_unicity: forall n m p : nat, n < m /\ p = m \/ m <= n /\ p = n -> p = Nat.max n m
max_unicity_ext: forall f : nat -> nat -> nat, (forall n m : nat, n < m /\ f n m = m \/ m <= n /\ f n m = n) -> forall n m : nat, f n m = Nat.max n m
min_0_l: forall n : nat, Nat.min 0 n = 0
min_0_r: forall n : nat, Nat.min n 0 = 0
min_assoc: forall m n p : nat, Nat.min m (Nat.min n p) = Nat.min (Nat.min m n) p
min_case: forall (n m : nat) (P : nat -> Type), P n -> P m -> P (Nat.min n m)
min_case_strong: forall (n m : nat) (P : nat -> Type), (n <= m -> P n) -> (m <= n -> P m) -> P (Nat.min n m)
min_comm: forall n m : nat, Nat.min n m = Nat.min m n
min_dec: forall n m : nat, {Nat.min n m = n} + {Nat.min n m = m}
min_glb: forall n m p : nat, p <= n -> p <= m -> p <= Nat.min n m
min_glb_iff: forall n m p : nat, p <= Nat.min n m <-> p <= n /\ p <= m
min_glb_l: forall n m p : nat, p <= Nat.min n m -> p <= n
min_glb_lt: forall n m p : nat, p < n -> p < m -> p < Nat.min n m
min_glb_lt_iff: forall n m p : nat, p < Nat.min n m <-> p < n /\ p < m
min_glb_r: forall n m p : nat, p <= Nat.min n m -> p <= m
min_id: forall n : nat, Nat.min n n = n
min_l: forall n m : nat, n <= m -> Init.Nat.min n m = n
min_l: forall n m : nat, n <= m -> Nat.min n m = n
min_l_iff: forall n m : nat, Nat.min n m = n <-> n <= m
min_le: forall n m p : nat, Nat.min n m <= p -> n <= p \/ m <= p
min_le_compat: forall n m p q : nat, n <= m -> p <= q -> Nat.min n p <= Nat.min m q
min_le_compat_l: forall n m p : nat, n <= m -> Nat.min p n <= Nat.min p m
min_le_compat_r: forall n m p : nat, n <= m -> Nat.min n p <= Nat.min m p
min_le_iff: forall n m p : nat, Nat.min n m <= p <-> n <= p \/ m <= p
min_lt_iff: forall n m p : nat, Nat.min n m < p <-> n < p \/ m < p
min_max_absorption: forall n m : nat, Nat.max n (Nat.min n m) = n
min_max_antimono: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful eq eq) f -> Morphisms.Proper (Morphisms.respectful le (Basics.flip le)) f -> forall x y : nat, Nat.min (f x) (f y) = f (Nat.max x y)
min_max_antimonotone: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful le (Basics.flip le)) f -> forall x y : nat, Nat.min (f x) (f y) = f (Nat.max x y)
min_max_distr: forall n m p : nat, Nat.min n (Nat.max m p) = Nat.max (Nat.min n m) (Nat.min n p)
min_max_modular: forall n m p : nat, Nat.min n (Nat.max m (Nat.min n p)) = Nat.max (Nat.min n m) (Nat.min n p)
min_mono: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful eq eq) f -> Morphisms.Proper (Morphisms.respectful le le) f -> forall x y : nat, Nat.min (f x) (f y) = f (Nat.min x y)
min_monotone: forall f : nat -> nat, Morphisms.Proper (Morphisms.respectful le le) f -> forall x y : nat, Nat.min (f x) (f y) = f (Nat.min x y)
min_r: forall n m : nat, m <= n -> Init.Nat.min n m = m
min_r: forall n m : nat, m <= n -> Nat.min n m = m
min_r_iff: forall n m : nat, Nat.min n m = m <-> m <= n
min_spec: forall n m : nat, n < m /\ Nat.min n m = n \/ m <= n /\ Nat.min n m = m
min_spec_le: forall n m : nat, n <= m /\ Nat.min n m = n \/ m <= n /\ Nat.min n m = m
min_unicity: forall n m p : nat, n < m /\ p = n \/ m <= n /\ p = m -> p = Nat.min n m
min_unicity_ext: forall f : nat -> nat -> nat, (forall n m : nat, n < m /\ f n m = n \/ m <= n /\ f n m = m) -> forall n m : nat, f n m = Nat.min n m
mul_0_l: forall n : nat, 0 * n = 0
mul_0_r: forall n : nat, n * 0 = 0
mul_1_l: forall n : nat, 1 * n = n
mul_1_r: forall n : nat, n * 1 = n
mul_2_mono_l: forall n m : nat, n < m -> 1 + 2 * n < 2 * m
mul_add_distr_l: forall n m p : nat, n * (m + p) = n * m + n * p
mul_add_distr_r: forall n m p : nat, (n + m) * p = n * p + m * p
mul_assoc: forall n m p : nat, n * (m * p) = n * m * p
mul_cancel_l: forall n m p : nat, p <> 0 -> p * n = p * m <-> n = m
mul_cancel_r: forall n m p : nat, p <> 0 -> n * p = m * p <-> n = m
mul_comm: forall n m : nat, n * m = m * n
mul_div_le: forall a b : nat, b <> 0 -> b * (a / b) <= a
mul_divide_cancel_l: forall n m p : nat, p <> 0 -> Nat.divide (p * n) (p * m) <-> Nat.divide n m
mul_divide_cancel_r: forall n m p : nat, p <> 0 -> Nat.divide (n * p) (m * p) <-> Nat.divide n m
mul_divide_mono_l: forall n m p : nat, Nat.divide n m -> Nat.divide (p * n) (p * m)
mul_divide_mono_r: forall n m p : nat, Nat.divide n m -> Nat.divide (n * p) (m * p)
mul_eq_0: forall n m : nat, n * m = 0 <-> n = 0 \/ m = 0
mul_eq_0_l: forall n m : nat, n * m = 0 -> m <> 0 -> n = 0
mul_eq_0_r: forall n m : nat, n * m = 0 -> n <> 0 -> m = 0
mul_eq_1: forall n m : nat, n * m = 1 <-> n = 1 /\ m = 1
mul_id_l: forall n m : nat, m <> 0 -> n * m = m <-> n = 1
mul_id_r: forall n m : nat, n <> 0 -> n * m = n <-> m = 1
mul_le_mono: forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q
mul_le_mono_l: forall n m p : nat, n <= m -> p * n <= p * m
mul_le_mono_neg_l: forall n m p : nat, p < 0 -> n <= m <-> p * m <= p * n
mul_le_mono_neg_r: forall n m p : nat, p < 0 -> n <= m <-> m * p <= n * p
mul_le_mono_nonneg: forall n m p q : nat, 0 <= n -> n <= m -> 0 <= p -> p <= q -> n * p <= m * q
mul_le_mono_nonneg_l: forall n m p : nat, 0 <= p -> n <= m -> p * n <= p * m
mul_le_mono_nonneg_r: forall n m p : nat, 0 <= p -> n <= m -> n * p <= m * p
mul_le_mono_nonpos_l: forall n m p : nat, p <= 0 -> n <= m -> p * m <= p * n
mul_le_mono_nonpos_r: forall n m p : nat, p <= 0 -> n <= m -> m * p <= n * p
mul_le_mono_pos_l: forall n m p : nat, 0 < p -> n <= m <-> p * n <= p * m
mul_le_mono_pos_r: forall n m p : nat, 0 < p -> n <= m <-> n * p <= m * p
mul_le_mono_r: forall n m p : nat, n <= m -> n * p <= m * p
mul_lt_mono: forall n m p q : nat, n < m -> p < q -> n * p < m * q
mul_lt_mono_neg_l: forall p n m : nat, p < 0 -> n < m <-> p * m < p * n
mul_lt_mono_neg_r: forall p n m : nat, p < 0 -> n < m <-> m * p < n * p
mul_lt_mono_nonneg: forall n m p q : nat, 0 <= n -> n < m -> 0 <= p -> p < q -> n * p < m * q
mul_lt_mono_pos_l: forall p n m : nat, 0 < p -> n < m <-> p * n < p * m
mul_lt_mono_pos_r: forall p n m : nat, 0 < p -> n < m <-> n * p < m * p
mul_lt_pred: forall p q n m : nat, S p = q -> p * n < p * m <-> q * n + m < q * m + n
mul_max_distr_l: forall n m p : nat, Nat.max (p * n) (p * m) = p * Nat.max n m
mul_max_distr_r: forall n m p : nat, Nat.max (n * p) (m * p) = Nat.max n m * p
mul_min_distr_l: forall n m p : nat, Nat.min (p * n) (p * m) = p * Nat.min n m
mul_min_distr_r: forall n m p : nat, Nat.min (n * p) (m * p) = Nat.min n m * p
mul_succ_l: forall n m : nat, S n * m = n * m + m
mul_succ_r: forall n m : nat, n * S m = n * m + n
mult_is_O: forall n m : nat, n * m = 0 -> n = 0 \/ m = 0
mult_is_one: forall n m : nat, n * m = 1 -> n = 1 /\ m = 1
mult_le_compat: forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q
mult_le_compat_l: forall n m p : nat, n <= m -> p * n <= p * m
mult_le_compat_r: forall n m p : nat, n <= m -> n * p <= m * p
mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m
mult_lt_compat_r: forall n m p : nat, n < m -> 0 < p -> n * p < m * p
mult_n_O: forall n : nat, 0 = n * 0
mult_n_Sm: forall n m : nat, n * m + n = n * S m
mult_O_le: forall n m : nat, m = 0 \/ n <= m * n
mult_S_le_reg_l: forall n m p : nat, S n * m <= S n * p -> m <= p
mult_S_lt_compat_l: forall n m p : nat, m < p -> S n * m < S n * p
zero_one: forall n : nat, n = 0 \/ n = 1 \/ 1 < n
zero_or_succ: forall n : nat, n = 0 \/ (exists m : nat, n = S m)
pow_0_l: forall a : nat, a <> 0 -> 0 ^ a = 0
pow_0_r: forall a : nat, a ^ 0 = 1
pow_1_l: forall a : nat, 1 ^ a = 1
pow_1_r: forall a : nat, a ^ 1 = a
pow_2_r: forall a : nat, a ^ 2 = a * a
pow_add_lower: forall a b c : nat, c <> 0 -> a ^ c + b ^ c <= (a + b) ^ c
pow_add_r: forall a b c : nat, a ^ (b + c) = a ^ b * a ^ c
pow_add_upper: forall a b c : nat, c <> 0 -> (a + b) ^ c <= 2 ^ Nat.pred c * (a ^ c + b ^ c)
pow_div_l: forall a b c : nat, b <> 0 -> a mod b = 0 -> (a / b) ^ c = a ^ c / b ^ c
pow_eq_0: forall a b : nat, b <> 0 -> a ^ b = 0 -> a = 0
pow_eq_0_iff: forall a b : nat, a ^ b = 0 <-> b <> 0 /\ a = 0
pow_gt_1: forall a b : nat, 1 < a -> b <> 0 -> 1 < a ^ b
pow_gt_lin_r: forall a b : nat, 1 < a -> b < a ^ b
pow_inj_l: forall a b c : nat, c <> 0 -> a ^ c = b ^ c -> a = b
pow_inj_r: forall a b c : nat, 1 < a -> a ^ b = a ^ c -> b = c
pow_le_mono: forall a b c d : nat, a <> 0 -> a <= c -> b <= d -> a ^ b <= c ^ d
pow_le_mono_l: forall a b c : nat, a <= b -> a ^ c <= b ^ c
pow_le_mono_l_iff: forall a b c : nat, c <> 0 -> a <= b <-> a ^ c <= b ^ c
pow_le_mono_r: forall a b c : nat, a <> 0 -> b <= c -> a ^ b <= a ^ c
pow_le_mono_r_iff: forall a b c : nat, 1 < a -> b <= c <-> a ^ b <= a ^ c
pow_lt_mono: forall a b c d : nat, 0 < a < c -> 0 < b < d -> a ^ b < c ^ d
pow_lt_mono_l: forall a b c : nat, c <> 0 -> a < b -> a ^ c < b ^ c
pow_lt_mono_l_iff: forall a b c : nat, c <> 0 -> a < b <-> a ^ c < b ^ c
pow_lt_mono_r: forall a b c : nat, 1 < a -> b < c -> a ^ b < a ^ c
pow_lt_mono_r_iff: forall a b c : nat, 1 < a -> b < c <-> a ^ b < a ^ c
pow_mul_l: forall a b c : nat, (a * b) ^ c = a ^ c * b ^ c
pow_mul_r: forall a b c : nat, a ^ (b * c) = (a ^ b) ^ c
pow_neg_r: forall a b : nat, b < 0 -> a ^ b = 0
pow_nonzero: forall a b : nat, a <> 0 -> a ^ b <> 0
pow_sub_r: forall a b c : nat, a <> 0 -> c <= b -> a ^ (b - c) = a ^ b / a ^ c
pow_succ_r': forall a b : nat, a ^ S b = a * a ^ b
pow_succ_r: forall a b : nat, 0 <= b -> a ^ S b = a * a ^ b
*)



(*
A'A_left: forall (A : nat -> Prop) (z : nat), (forall n : nat, (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) n) -> forall n : nat, n <= z -> A n
A'A_right: forall (A : nat -> Prop) (z : nat), (forall n : nat, (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n) -> forall n : nat, z <= n -> A n
Acc_intro_generator: forall [A : Type] [R : A -> A -> Prop], nat -> well_founded R -> well_founded R
acc_lt_rel: forall (A : Set) (R : A -> A -> Prop) (F : A -> nat -> Prop), (forall x y : A, R x y -> inv_lt_rel A F x y) -> forall x : A, (exists n : nat, F x n) -> Acc R x
add_b2n_double_bit0: forall (a0 : bool) (a : nat), Nat.testbit (Nat.b2n a0 + 2 * a) 0 = a0
add_b2n_double_div2: forall (a0 : bool) (a : nat), (Nat.b2n a0 + 2 * a) / 2 = a
add_bit0: forall a b : nat, Nat.testbit (a + b) 0 = xorb (Nat.testbit a 0) (Nat.testbit b 0)
add_bit1: forall a b : nat, Nat.testbit (a + b) 1 = xorb (xorb (Nat.testbit a 1) (Nat.testbit b 1)) (Nat.testbit a 0 && Nat.testbit b 0)
*)


(*
add_carry_bits: forall (a b : nat) (c0 : bool), exists c : nat, a + b + Nat.b2n c0 = Nat.lxor (Nat.lxor a b) c /\ c / 2 = Nat.lor (Nat.land a b) (Nat.land c (Nat.lor a b)) /\ Nat.testbit c 0 = c0
add_carry_div2: forall (a b : nat) (c0 : bool), (a + b + Nat.b2n c0) / 2 = a / 2 + b / 2 + Nat.b2n (Nat.testbit a 0 && Nat.testbit b 0 || c0 && (Nat.testbit a 0 || Nat.testbit b 0))

Add_length: forall [A : Type] [a : A] [l l' : list A], List.Add a l l' -> Datatypes.length l' = S (Datatypes.length l)
add_lnot_diag_low: forall a n : nat, Nat.log2 a < n -> a + Nat.lnot a n = Nat.ones n
add_log2_lt: forall a b : nat, 0 < a -> 0 < b -> Nat.log2 a + Nat.log2 b < 2 * Nat.log2 (a + b)
add_log2_up_lt: forall a b : nat, 0 < a -> 0 < b -> Nat.log2_up a + Nat.log2_up b < 2 * Nat.log2_up (a + b)


add_mod: forall a b n : nat, n <> 0 -> (a + b) mod n = (a mod n + b mod n) mod n
add_mod_idemp_l: forall a b n : nat, n <> 0 -> (a mod n + b) mod n = (a + b) mod n
add_mod_idemp_r: forall a b n : nat, n <> 0 -> (a + b mod n) mod n = (a + b) mod n

add_nocarry_lt_pow2: forall a b n : nat, Nat.land a b = 0 -> a < 2 ^ n -> b < 2 ^ n -> a + b < 2 ^ n
add_nocarry_lxor: forall a b : nat, Nat.land a b = 0 -> a + b = Nat.lxor a b
add_nocarry_mod_lt_pow2: forall a b n : nat, Nat.land a b = 0 -> a mod 2 ^ n + b mod 2 ^ n < 2 ^ n


add_pred_l: forall n m : nat, n <> 0 -> Nat.pred n + m = Nat.pred (n + m)
add_pred_r: forall n m : nat, m <> 0 -> n + Nat.pred m = Nat.pred (n + m)
add_shuffle0: forall n m p : nat, n + m + p = n + p + m
add_shuffle1: forall n m p q : nat, n + m + (p + q) = n + p + (m + q)
add_shuffle2: forall n m p q : nat, n + m + (p + q) = n + q + (m + p)
add_shuffle3: forall n m p : nat, n + (m + p) = m + (n + p)
add_sqrt_le: forall a b : nat, Nat.sqrt a + Nat.sqrt b <= Nat.sqrt (2 * (a + b))
add_sqrt_up_le: forall a b : nat, 0 <= a -> 0 <= b -> Nat.sqrt_up a + Nat.sqrt_up b <= S (Nat.sqrt_up (2 * (a + b)))
add_square_le: forall a b : nat, 0 <= a -> 0 <= b -> a * a + b * b <= (a + b) * (a + b)
add_sub: forall n m : nat, n + m - m = n
add_sub_assoc: forall n m p : nat, p <= m -> n + (m - p) = n + m - p
add_sub_eq_l: forall n m p : nat, m + p = n -> n - m = p
add_sub_eq_nz: forall n m p : nat, p <> 0 -> n - m = p -> m + p = n
add_sub_eq_r: forall n m p : nat, m + p = n -> n - p = m
add_sub_swap: forall n m p : nat, p <= n -> n + m - p = n - p + m

add3_bit0: forall a b c : nat, Nat.testbit (a + b + c) 0 = xorb (xorb (Nat.testbit a 0) (Nat.testbit b 0)) (Nat.testbit c 0)
add3_bits_div2: forall a0 b0 c0 : bool, (Nat.b2n a0 + Nat.b2n b0 + Nat.b2n c0) / 2 = Nat.b2n (a0 && b0 || c0 && (a0 || b0))
app_length: forall [A : Type] (l l' : list A), Datatypes.length (l ++ l') = Datatypes.length l + Datatypes.length l'
app_nth1: forall [A : Type] (l l' : list A) (d : A) [n : nat], n < Datatypes.length l -> List.nth n (l ++ l') d = List.nth n l d
app_nth2: forall [A : Type] (l l' : list A) (d : A) [n : nat], n >= Datatypes.length l -> List.nth n (l ++ l') d = List.nth (n - Datatypes.length l) l' d
app_nth2_plus: forall [A : Type] (l l' : list A) (d : A) (n : nat), List.nth (Datatypes.length l + n) (l ++ l') d = List.nth n l' d
are_bits: forall f : nat -> bool, Morphisms.Proper (Morphisms.respectful eq eq) f -> (exists n : nat, Nat.eqf f (Nat.testbit n)) <-> (exists k : nat, forall m : nat, k <= m -> f m = false)
b2n_div2: forall a0 : bool, Nat.b2n a0 / 2 = 0
b2n_inj: forall a0 b0 : bool, Nat.b2n a0 = Nat.b2n b0 -> a0 = b0
beq_nat_eq: forall n m : nat, true = (n =? m) -> n = m
beq_nat_false: forall n m : nat, (n =? m) = false -> n <> m
beq_nat_refl: forall n : nat, true = (n =? n)
beq_nat_true: forall n m : nat, (n =? m) = true -> n = m
bet_emp: forall (P : nat -> Prop) (k : nat), between P k k
bet_eq: forall (P : nat -> Prop) (k l : nat), l = k -> between P k l
bet_S: forall (P : nat -> Prop) (k l : nat), between P k l -> P l -> between P k (S l)
between_in_int: forall (P : nat -> Prop) (k l : nat), between P k l -> forall r : nat, in_int k l r -> P r
between_ind: forall (P : nat -> Prop) (k : nat) (P0 : nat -> Prop), P0 k -> (forall l : nat, between P k l -> P0 l -> P l -> P0 (S l)) -> forall n : nat, between P k n -> P0 n
between_le: forall (P : nat -> Prop) (k l : nat), between P k l -> k <= l
between_not_exists: forall (P Q : nat -> Prop) (k l : nat), between P k l -> (forall n : nat, in_int k l n -> P n -> ~ Q n) -> ~ exists_between Q k l
between_or_exists: forall (P Q : nat -> Prop) (k l : nat), k <= l -> (forall n : nat, in_int k l n -> P n \/ Q n) -> between P k l \/ exists_between Q k l
between_restr: forall (P : nat -> Prop) (k l m : nat), k <= l -> l <= m -> between P k m -> between P l m
between_sind: forall (P : nat -> Prop) (k : nat) (P0 : nat -> SProp), P0 k -> (forall l : nat, between P k l -> P0 l -> P l -> P0 (S l)) -> forall n : nat, between P k n -> P0 n
between_Sk_l: forall (P : nat -> Prop) (k l : nat), between P k l -> S k <= l -> between P (S k) l
bezout_1_gcd: forall n m : nat, Nat.Bezout n m 1 -> Nat.gcd n m = 1
bezout_comm: forall a b g : nat, b <> 0 -> Nat.Bezout a b g -> Nat.Bezout b a g
bi_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> A 0 -> (forall n : nat, A n <-> A (S n)) -> forall n : nat, A n
bit_log2: forall a : nat, a <> 0 -> Nat.testbit a (Nat.log2 a) = true
bit0_eqb: forall a : nat, Nat.testbit a 0 = (a mod 2 =? 1)
bit0_mod: forall a : nat, Nat.b2n (Nat.testbit a 0) = a mod 2
bit0_odd: forall a : nat, Nat.testbit a 0 = Nat.odd a
bits_0: forall n : nat, Nat.testbit 0 n = false
bits_above_log2: forall a n : nat, Nat.log2 a < n -> Nat.testbit a n = false
bits_inj: forall a b : nat, Nat.eqf (Nat.testbit a) (Nat.testbit b) -> a = b
bits_inj_0: forall a : nat, (forall n : nat, Nat.testbit a n = false) -> a = 0
bits_inj_iff: forall a b : nat, Nat.eqf (Nat.testbit a) (Nat.testbit b) <-> a = b
bool_ring_ring_lemma1: forall (n : nat) (l : list bool) (lpe : list (Ring_polynom.PExpr bool * Ring_polynom.PExpr bool)) (pe1 pe2 : Ring_polynom.PExpr bool), Ring_polynom.interp_PElist false true xorb andb xorb (fun b : bool => b) eq (IDphi (R:=bool)) id_phi_N (pow_N true andb) l lpe -> (let lmp := Ring_polynom.mk_monpol_list false true xorb andb xorb (fun b : bool => b) bool_eq (triv_div false true bool_eq) lpe in Ring_polynom.Peq bool_eq (Ring_polynom.norm_subst false true xorb andb xorb (fun b : bool => b) bool_eq (triv_div false true bool_eq) n lmp pe1) (Ring_polynom.norm_subst false true xorb andb xorb (fun b : bool => b) bool_eq (triv_div false true bool_eq) n lmp pe2)) = true -> Ring_polynom.PEeval false true xorb andb xorb (fun b : bool => b) (IDphi (R:=bool)) id_phi_N (pow_N true andb) l pe1 = Ring_polynom.PEeval false true xorb andb xorb (fun b : bool => b) (IDphi (R:=bool)) id_phi_N (pow_N true andb) l pe2
bool_ring_ring_lemma2: forall (n : nat) (lH : list (Ring_polynom.PExpr bool * Ring_polynom.PExpr bool)) (l : list bool), Ring_polynom.interp_PElist false true xorb andb xorb (fun b : bool => b) eq (IDphi (R:=bool)) id_phi_N (pow_N true andb) l lH -> forall lmp : list (bool * Ring_polynom.Mon * Ring_polynom.Pol bool), Ring_polynom.mk_monpol_list false true xorb andb xorb (fun b : bool => b) bool_eq (triv_div false true bool_eq) lH = lmp -> forall (pe : Ring_polynom.PExpr bool) (npe : Ring_polynom.Pol bool), Ring_polynom.norm_subst false true xorb andb xorb (fun b : bool => b) bool_eq (triv_div false true bool_eq) n lmp pe = npe -> Ring_polynom.PEeval false true xorb andb xorb (fun b : bool => b) (IDphi (R:=bool)) id_phi_N (pow_N true andb) l pe = Ring_polynom.Pphi_dev false true xorb andb xorb (fun b : bool => b) false true bool_eq (IDphi (R:=bool)) (get_sign_None (C:=bool)) l npe
Build_Params: forall (A : Type) (of : A) (arity : nat), CMorphisms.Params of arity
Build_Params: forall (A : Type) (of : A) (arity : nat), Morphisms.Params of arity
case_analysis: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> A 0 -> (forall n : nat, A (S n)) -> forall n : nat, A n
central_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, A z -> (forall n : nat, A n <-> A (S n)) -> forall n : nat, A n
clearbit_eq: forall a n : nat, Nat.testbit (Nat.clearbit a n) n = false
clearbit_eqb: forall a n m : nat, Nat.testbit (Nat.clearbit a n) m = (Nat.testbit a m && negb (n =? m))%bool
clearbit_iff: forall a n m : nat, Nat.testbit (Nat.clearbit a n) m = true <-> Nat.testbit a m = true /\ n <> m
clearbit_neq: forall a n m : nat, n <> m -> Nat.testbit (Nat.clearbit a n) m = Nat.testbit a m
clearbit_spec': forall a n : nat, Nat.clearbit a n = Nat.ldiff a (2 ^ n)
combine_firstn: forall [A B : Type] (l : list A) (l' : list B) (n : nat), List.firstn n (List.combine l l') = List.combine (List.firstn n l) (List.firstn n l')
combine_length: forall [A B : Type] (l : list A) (l' : list B), Datatypes.length (List.combine l l') = Init.Nat.min (Datatypes.length l) (Datatypes.length l')
combine_nth: forall [A B : Type] (l : list A) (l' : list B) (n : nat) (x : A) (y : B), Datatypes.length l = Datatypes.length l' -> List.nth n (List.combine l l') (x, y) = (List.nth n l x, List.nth n l' y)
combine_split: forall [A B : Type] (l : list A) (l' : list B), Datatypes.length l = Datatypes.length l' -> List.split (List.combine l l') = (l, l')
compare_antisym: forall n m : nat, (m ?= n) = CompOpp (n ?= m)
compare_eq: forall x y : nat, (x ?= y) = Eq -> x = y
compare_eq_iff: forall n m : nat, (n ?= m) = Eq <-> n = m
compare_ge_iff: forall x y : nat, (x ?= y) <> Lt <-> y <= x
compare_gt_iff: forall x y : nat, (x ?= y) = Gt <-> y < x
compare_le_iff: forall n m : nat, (n ?= m) <> Gt <-> n <= m
compare_lt_iff: forall n m : nat, (n ?= m) = Lt <-> n < m
compare_nge_iff: forall x y : nat, (x ?= y) = Lt <-> ~ y <= x
compare_ngt_iff: forall x y : nat, (x ?= y) <> Gt <-> ~ y < x
compare_nle_iff: forall x y : nat, (x ?= y) = Gt <-> ~ x <= y
compare_nlt_iff: forall x y : nat, (x ?= y) <> Lt <-> ~ x < y
compare_refl: forall x : nat, (x ?= x) = Eq
compare_spec: forall x y : nat, CompareSpec (x = y) (x < y) (y < x) (x ?= y)
compare_succ: forall n m : nat, (S n ?= S m) = (n ?= m)
cons_seq: forall len start : nat, (start :: List.seq (S start) len)%list = List.seq start (S len)
count_occ': forall [A : Type], (forall x y : A, {x = y} + {x <> y}) -> list A -> A -> nat
count_occ: forall [A : Type], (forall x y : A, {x = y} + {x <> y}) -> list A -> A -> nat
count_occ_alt: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l : list A) (x : A), List.count_occ' eq_dec l x = List.count_occ eq_dec l x
count_occ_app: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l1 l2 : list A) (x : A), List.count_occ eq_dec (l1 ++ l2) x = List.count_occ eq_dec l1 x + List.count_occ eq_dec l2 x
count_occ_cons_eq: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l : list A) [x y : A], x = y -> List.count_occ eq_dec (x :: l) y = S (List.count_occ eq_dec l y)
count_occ_cons_neq: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l : list A) [x y : A], x <> y -> List.count_occ eq_dec (x :: l) y = List.count_occ eq_dec l y
count_occ_elt_eq: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l1 l2 : list A) [x y : A], x = y -> List.count_occ eq_dec (l1 ++ x :: l2) y = S (List.count_occ eq_dec (l1 ++ l2) y)
count_occ_elt_neq: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l1 l2 : list A) [x y : A], x <> y -> List.count_occ eq_dec (l1 ++ x :: l2) y = List.count_occ eq_dec (l1 ++ l2) y
count_occ_inv_nil: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l : list A), (forall x : A, List.count_occ eq_dec l x = 0) <-> l = Datatypes.nil
count_occ_map: forall [A B : Type] (f : A -> B) (decA : forall x1 x2 : A, {x1 = x2} + {x1 <> x2}) (decB : forall y1 y2 : B, {y1 = y2} + {y1 <> y2}), (forall x1 x2 : A, f x1 = f x2 -> x1 = x2) -> forall (x : A) (l : list A), List.count_occ decA l x = List.count_occ decB (List.map f l) (f x)
count_occ_nil: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (x : A), List.count_occ eq_dec Datatypes.nil x = 0
count_occ_not_In: forall [A : Type] (eq_dec : forall x y : A, {x = y} + {x <> y}) (l : list A) (x : A), ~ List.In x l <-> List.count_occ eq_dec l x = 0
count_occ_repeat_eq: forall [A : Type] (decA : forall x y : A, {x = y} + {x <> y}) [x y : A] (n : nat), x = y -> List.count_occ decA (List.repeat y n) x = n
count_occ_repeat_excl: forall [A : Type] (decA : forall x y : A, {x = y} + {x <> y}) [x : A] (l : list A), (forall y : A, y <> x -> List.count_occ decA l y = 0) -> l = List.repeat x (Datatypes.length l)
count_occ_repeat_neq: forall [A : Type] (decA : forall x y : A, {x = y} + {x <> y}) [x y : A] (n : nat), x <> y -> List.count_occ decA (List.repeat y n) x = 0
count_occ_sgt: forall [A : Type] (decA : forall x y : A, {x = y} + {x <> y}) (l : list A) (x : A), l = (x :: Datatypes.nil)%list <-> List.count_occ decA l x = 1 /\ (forall y : A, y <> x -> List.count_occ decA l y = 0)
count_occ_unique: forall [A : Type] (decA : forall x y : A, {x = y} + {x <> y}) (x : A) (l : list A), List.count_occ decA l x = Datatypes.length l -> l = List.repeat x (Datatypes.length l)
crossmul_le_addsquare: forall a b : nat, 0 <= a -> 0 <= b -> b * a + a * b <= a * a + b * b
dec_eq_nat: forall n m : nat, Decidable.decidable (n = m)
dec_ge: forall n m : nat, Decidable.decidable (n >= m)
dec_gt: forall n m : nat, Decidable.decidable (n > m)
dec_inh_nat_subset_has_unique_least_element: forall P : nat -> Prop, (forall n : nat, P n \/ ~ P n) -> (exists n : nat, P n) -> has_unique_least_element le P
dec_le: forall n m : nat, Decidable.decidable (n <= m)
dec_lt: forall n m : nat, Decidable.decidable (n < m)
dependent_choice: forall [X : Set] [R : X -> X -> Prop], (forall x : X, {y : X | R x y}) -> forall x0 : X, {f : nat -> X | f 0 = x0 /\ (forall n : nat, R (f n) (f (S n)))}
div_0_l: forall a : nat, a <> 0 -> 0 / a = 0
div_1_l: forall a : nat, 1 < a -> 1 / a = 0
div_1_r: forall a : nat, a / 1 = a
div_add: forall a b c : nat, c <> 0 -> (a + b * c) / c = a / c + b
div_add_l: forall a b c : nat, b <> 0 -> (a * b + c) / b = a + c / b
div_div: forall a b c : nat, b <> 0 -> c <> 0 -> a / b / c = a / (b * c)
div_exact: forall a b : nat, b <> 0 -> a = b * (a / b) <-> a mod b = 0
div_le_compat_l: forall p q r : nat, 0 < q <= r -> p / r <= p / q
div_le_lower_bound: forall a b q : nat, b <> 0 -> b * q <= a -> q <= a / b
div_le_mono: forall a b c : nat, c <> 0 -> a <= b -> a / c <= b / c
div_le_upper_bound: forall a b q : nat, b <> 0 -> a <= b * q -> a / b <= q
div_lt: forall a b : nat, 0 < a -> 1 < b -> a / b < a
div_lt_upper_bound: forall a b q : nat, b <> 0 -> a < b * q -> a / b < q
div_mod: forall x y : nat, y <> 0 -> x = y * (x / y) + x mod y
div_mod_eq: forall x y : nat, x = y * (x / y) + x mod y
div_mod_unique: forall b q1 q2 r1 r2 : nat, r1 < b -> r2 < b -> b * q1 + r1 = b * q2 + r2 -> q1 = q2 /\ r1 = r2
div_mul: forall a b : nat, b <> 0 -> a * b / b = a
div_mul_cancel_l: forall a b c : nat, b <> 0 -> c <> 0 -> c * a / (c * b) = a / b
div_mul_cancel_r: forall a b c : nat, b <> 0 -> c <> 0 -> a * c / (b * c) = a / b
div_mul_le: forall a b c : nat, b <> 0 -> c * (a / b) <= c * a / b
div_pow2_bits: forall a n m : nat, Nat.testbit (a / 2 ^ n) m = Nat.testbit a (m + n)
div_same: forall a : nat, a <> 0 -> a / a = 1
div_small: forall a b : nat, a < b -> a / b = 0
div_small_iff: forall a b : nat, b <> 0 -> a / b = 0 <-> a < b
div_str_pos: forall a b : nat, 0 < b <= a -> 0 < a / b
div_str_pos_iff: forall a b : nat, b <> 0 -> 0 < a / b <-> b <= a
div_unique: forall a b q r : nat, r < b -> a = b * q + r -> q = a / b
div_unique_exact: forall a b q : nat, b <> 0 -> a = b * q -> q = a / b
div2_bits: forall a n : nat, Nat.testbit (a / 2) n = Nat.testbit a (S n)
div2_bitwise: forall (op : bool -> bool -> bool) (n a b : nat), Nat.div2 (Nat.bitwise op (S n) a b) = Nat.bitwise op n (Nat.div2 a) (Nat.div2 b)
div2_decr: forall a n : nat, a <= S n -> Nat.div2 a <= n
div2_div: forall a : nat, Nat.div2 a = a / 2
div2_double: forall n : nat, Nat.div2 (2 * n) = n
div2_odd: forall a : nat, a = 2 * Nat.div2 a + Nat.b2n (Nat.odd a)
div2_spec: forall a : nat, Nat.div2 a = Nat.shiftr a 1
div2_succ_double: forall n : nat, Nat.div2 (S (2 * n)) = n
divide_0_l: forall n : nat, Nat.divide 0 n -> n = 0
divide_0_r: forall n : nat, Nat.divide n 0
divide_1_l: forall n : nat, Nat.divide 1 n
divide_1_r: forall n : nat, Nat.divide n 1 -> n = 1
divide_1_r_nonneg: forall n : nat, 0 <= n -> Nat.divide n 1 -> n = 1
divide_add_cancel_r: forall n m p : nat, Nat.divide n m -> Nat.divide n (m + p) -> Nat.divide n p
divide_add_r: forall n m p : nat, Nat.divide n m -> Nat.divide n p -> Nat.divide n (m + p)
divide_antisym: forall n m : nat, Nat.divide n m -> Nat.divide m n -> n = m
divide_antisym_nonneg: forall n m : nat, 0 <= n -> 0 <= m -> Nat.divide n m -> Nat.divide m n -> n = m
divide_div: forall a b c : nat, a <> 0 -> Nat.divide a b -> Nat.divide b c -> Nat.divide (b / a) (c / a)
divide_div_mul_exact: forall a b c : nat, b <> 0 -> Nat.divide b a -> c * a / b = c * (a / b)
divide_factor_l: forall n m : nat, Nat.divide n (n * m)
divide_factor_r: forall n m : nat, Nat.divide n (m * n)
divide_gcd_iff': forall n m : nat, Nat.divide n m <-> Nat.gcd n m = n
divide_gcd_iff: forall n m : nat, 0 <= n -> Nat.divide n m <-> Nat.gcd n m = n
divide_lcm_eq_r: forall n m : nat, Nat.divide n m -> Nat.lcm n m = m
divide_lcm_iff: forall n m : nat, Nat.divide n m <-> Nat.lcm n m = m
divide_lcm_l: forall a b : nat, Nat.divide a (Nat.lcm a b)
divide_lcm_r: forall a b : nat, Nat.divide b (Nat.lcm a b)
divide_mul_l: forall n m p : nat, Nat.divide n m -> Nat.divide n (m * p)
divide_mul_r: forall n m p : nat, Nat.divide n p -> Nat.divide n (m * p)
divide_mul_split: forall n m p : nat, n <> 0 -> Nat.divide n (m * p) -> exists q r : nat, n = q * r /\ Nat.divide q m /\ Nat.divide r p
divide_pos_le: forall n m : nat, 0 < m -> Nat.divide n m -> n <= m
divide_refl: forall n : nat, Nat.divide n n
divide_sub_r: forall n m p : nat, Nat.divide n m -> Nat.divide n p -> Nat.divide n (m - p)
divide_trans: forall n m p : nat, Nat.divide n m -> Nat.divide m p -> Nat.divide n p
divmod_spec: forall x y q u : nat, u <= y -> let (q', u') := Nat.divmod x y q u in x + S y * q + (y - u) = S y * q' + (y - u') /\ u' <= y
double_above: forall n m : nat, n < m -> 2 * n + 1 < 2 * m
double_below: forall n m : nat, n <= m -> 2 * n < 2 * m + 1
double_bits_succ: forall a n : nat, Nat.testbit (2 * a) (S n) = Nat.testbit a n
double_induction: forall R : nat -> nat -> Prop, Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff)) R -> (forall m : nat, R 0 m) -> (forall n : nat, R (S n) 0) -> (forall n m : nat, R n m -> R (S n) (S m)) -> forall n m : nat, R n m
double_twice: forall n : nat, Nat.double n = 2 * n


eq_add_succ: forall n m : nat, (exists p : nat, n + m = S p) <-> (exists n' : nat, n = S n') \/ (exists m' : nat, m = S m')
eq_dec: forall n m : nat, {n = m} + {n <> m}
eq_decidable: forall n m : nat, Decidable.decidable (n = m)
eq_dne: forall n m : nat, ~ n <> m <-> n = m
eq_eq_nat: forall n m : nat, n = m -> eq_nat n m
eq_le_incl: forall n m : nat, n = m -> n <= m
eq_mul_0: forall n m : nat, n * m = 0 <-> n = 0 \/ m = 0
eq_mul_0_l: forall n m : nat, n * m = 0 -> m <> 0 -> n = 0
eq_mul_0_r: forall n m : nat, n * m = 0 -> n <> 0 -> m = 0
eq_mul_1: forall n m : nat, n * m = 1 <-> n = 1 /\ m = 1
eq_mul_1_nonneg': forall n m : nat, 0 <= m -> n * m = 1 -> n = 1 /\ m = 1
eq_mul_1_nonneg: forall n m : nat, 0 <= n -> n * m = 1 -> n = 1 /\ m = 1
eq_nat_decide: forall n m : nat, {eq_nat n m} + {~ eq_nat n m}
eq_nat_elim: forall (n : nat) (P : nat -> Prop), P n -> forall m : nat, eq_nat n m -> P m
eq_nat_eq: forall n m : nat, eq_nat n m -> n = m
eq_nat_is_eq: forall n m : nat, eq_nat n m <-> n = m
eq_nat_refl: forall n : nat, eq_nat n n
eq_pred_0: forall n : nat, Nat.pred n = 0 <-> n = 0 \/ n = 1
eq_S: forall x y : nat, x = y -> S x = S y
eq_square_0: forall n : nat, n * n = 0 <-> n = 0
eq_stepl: forall x y z : nat, x = y -> x = z -> z = y
eq_sym_iff: forall x y : nat, x = y <-> y = x
eqb_compare: forall x y : nat, (x =? y) = match x ?= y with | Eq => true | _ => false end
eqb_eq: forall n m : nat, (n =? m) = true <-> n = m
eqb_neq: forall x y : nat, (x =? y) = false <-> x <> y
eqb_refl: forall x : nat, (x =? x) = true
eqb_spec: forall x y : nat, Bool.reflect (x = y) (x =? y)
eqb_sym: forall x y : nat, (x =? y) = (y =? x)
even_add: forall n m : nat, Nat.even (n + m) = Bool.eqb (Nat.even n) (Nat.even m)
even_add_even: forall n m : nat, Nat.Even m -> Nat.even (n + m) = Nat.even n
even_add_mul_2: forall n m : nat, Nat.even (n + 2 * m) = Nat.even n
even_add_mul_even: forall n m p : nat, Nat.Even m -> Nat.even (n + m * p) = Nat.even n
even_mul: forall n m : nat, Nat.even (n * m) = (Nat.even n || Nat.even m)%bool
Even_Odd_False: forall x : nat, Nat.Even x -> Nat.Odd x -> False
Even_or_Odd: forall x : nat, Nat.Even x \/ Nat.Odd x
even_pow: forall a b : nat, b <> 0 -> Nat.even (a ^ b) = Nat.even a
even_pred: forall n : nat, n <> 0 -> Nat.even (Nat.pred n) = Nat.odd n
even_spec: forall n : nat, Nat.even n = true <-> Nat.Even n
even_sub: forall n m : nat, m <= n -> Nat.even (n - m) = Bool.eqb (Nat.even n) (Nat.even m)
Even_succ: forall n : nat, Nat.Even (S n) <-> Nat.Odd n
even_succ: forall n : nat, Nat.even (S n) = Nat.odd n
Even_succ_succ: forall n : nat, Nat.Even (S (S n)) <-> Nat.Even n
even_succ_succ: forall n : nat, Nat.even (S (S n)) = Nat.even n
event_O: forall Q : nat -> Prop, eventually Q 0 -> Q 0
exists_between_ind: forall (Q : nat -> Prop) (k : nat) (P : nat -> Prop), (forall l : nat, exists_between Q k l -> P l -> P (S l)) -> (forall l : nat, k <= l -> Q l -> P (S l)) -> forall n : nat, exists_between Q k n -> P n
exists_between_sind: forall (Q : nat -> Prop) (k : nat) (P : nat -> SProp), (forall l : nat, exists_between Q k l -> P l -> P (S l)) -> (forall l : nat, k <= l -> Q l -> P (S l)) -> forall n : nat, exists_between Q k n -> P n
exists_div2: forall a : nat, exists (a' : nat) (b : bool), a = 2 * a' + Nat.b2n b
exists_in_int: forall (Q : nat -> Prop) (k l : nat), exists_between Q k l -> exists2 m : nat, in_int k l m & Q m
exists_le: forall (Q : nat -> Prop) (k l : nat), k <= l -> Q l -> exists_between Q k (S l)
exists_le_S: forall (Q : nat -> Prop) (k l : nat), exists_between Q k l -> S k <= l
exists_lt: forall (Q : nat -> Prop) (k l : nat), exists_between Q k l -> k < l
Exists_nth: forall [A : Type] (P : A -> Prop) (l : list A), List.Exists P l <-> (exists (i : nat) (d : A), i < Datatypes.length l /\ P (List.nth i l d))
exists_S: forall (Q : nat -> Prop) (k l : nat), exists_between Q k l -> exists_between Q k (S l)
exists_S_le: forall (Q : nat -> Prop) (k l : nat), exists_between Q k (S l) -> k <= l
existsb_nth: forall [A : Type] (f : A -> bool) (l : list A) [n : nat] (d : A), n < Datatypes.length l -> List.existsb f l = false -> f (List.nth n l d) = false
f_equal_nat: forall (B : Type) (f : nat -> B) (x y : nat), x = y -> f x = f y
f_equal_pred: forall x y : nat, x = y -> Init.Nat.pred x = Init.Nat.pred y
f_equal2_mult: forall x1 y1 x2 y2 : nat, x1 = y1 -> x2 = y2 -> x1 * x2 = y1 * y2
f_equal2_nat: forall (B : Type) (f : nat -> nat -> B) (x1 y1 x2 y2 : nat), x1 = y1 -> x2 = y2 -> f x1 x2 = f y1 y2
f_equal2_plus: forall x1 y1 x2 y2 : nat, x1 = y1 -> x2 = y2 -> x1 + x2 = y1 + y2

firstn: forall [A : Type], nat -> list A -> list A
firstn_all2: forall [A : Type] [n : nat] (l : list A), Datatypes.length l <= n -> List.firstn n l = l
firstn_app: forall [A : Type] (n : nat) (l1 l2 : list A), List.firstn n (l1 ++ l2) = (List.firstn n l1 ++ List.firstn (n - Datatypes.length l1) l2)%list
firstn_app_2: forall [A : Type] (n : nat) (l1 l2 : list A), List.firstn (Datatypes.length l1 + n) (l1 ++ l2) = (l1 ++ List.firstn n l2)%list
firstn_cons: forall [A : Type] (n : nat) (a : A) (l : list A), List.firstn (S n) (a :: l) = (a :: List.firstn n l)%list
firstn_firstn: forall [A : Type] (l : list A) (i j : nat), List.firstn i (List.firstn j l) = List.firstn (Init.Nat.min i j) l
firstn_le_length: forall [A : Type] (n : nat) (l : list A), Datatypes.length (List.firstn n l) <= n
firstn_length: forall [A : Type] (n : nat) (l : list A), Datatypes.length (List.firstn n l) = Init.Nat.min n (Datatypes.length l)
firstn_length_le: forall [A : Type] (l : list A) [n : nat], n <= Datatypes.length l -> Datatypes.length (List.firstn n l) = n
firstn_map: forall [A B : Type] (f : A -> B) (n : nat) (l : list A), List.firstn n (List.map f l) = List.map f (List.firstn n l)
firstn_nil: forall (A : Type) (n : nat), List.firstn n Datatypes.nil = Datatypes.nil
firstn_removelast: forall [A : Type] [n : nat] (l : list A), n < Datatypes.length l -> List.firstn n (List.removelast l) = List.firstn n l
firstn_rev: forall [A : Type] (x : nat) (l : list A), List.firstn x (List.rev l) = List.rev (List.skipn (Datatypes.length l - x) l)
firstn_skipn: forall [A : Type] (n : nat) (l : list A), (List.firstn n l ++ List.skipn n l)%list = l
firstn_skipn_comm: forall [A : Type] (m n : nat) (l : list A), List.firstn m (List.skipn n l) = List.skipn n (List.firstn (n + m) l)
firstn_skipn_rev: forall [A : Type] (x : nat) (l : list A), List.firstn x l = List.rev (List.skipn (Datatypes.length l - x) (List.rev l))
fold_left_length: forall [A : Type] (l : list A), List.fold_left (fun (x : nat) (_ : A) => S x) l 0 = Datatypes.length l
Forall_nth: forall [A : Type] (P : A -> Prop) (l : list A), List.Forall P l <-> (forall (i : nat) (d : A), i < Datatypes.length l -> P (List.nth i l d))
gauss: forall n m p : nat, Nat.divide n (m * p) -> Nat.gcd n m = 1 -> Nat.divide n p
gcd_0_l: forall n : nat, Nat.gcd 0 n = n
gcd_0_l_nonneg: forall n : nat, 0 <= n -> Nat.gcd 0 n = n
gcd_0_r: forall n : nat, Nat.gcd n 0 = n
gcd_0_r_nonneg: forall n : nat, 0 <= n -> Nat.gcd n 0 = n
gcd_1_l: forall n : nat, Nat.gcd 1 n = 1
gcd_1_lcm_mul: forall n m : nat, n <> 0 -> m <> 0 -> Nat.gcd n m = 1 <-> Nat.lcm n m = n * m
gcd_1_r: forall n : nat, Nat.gcd n 1 = 1
gcd_add_diag_r: forall n m : nat, Nat.gcd n (m + n) = Nat.gcd n m
gcd_add_mult_diag_r: forall n m p : nat, Nat.gcd n (m + p * n) = Nat.gcd n m
gcd_assoc: forall n m p : nat, Nat.gcd n (Nat.gcd m p) = Nat.gcd (Nat.gcd n m) p
gcd_bezout: forall n m : nat, Nat.Bezout n m (Nat.gcd n m) \/ Nat.Bezout m n (Nat.gcd n m)
gcd_bezout_pos: forall n m : nat, 0 < n -> Nat.Bezout n m (Nat.gcd n m)
gcd_bezout_pos_pos: forall n : nat, 0 < n -> forall m : nat, 0 < m -> Nat.Bezout n m (Nat.gcd n m) /\ Nat.Bezout m n (Nat.gcd n m)
gcd_comm: forall n m : nat, Nat.gcd n m = Nat.gcd m n
gcd_diag: forall n : nat, Nat.gcd n n = n
gcd_diag_nonneg: forall n : nat, 0 <= n -> Nat.gcd n n = n
gcd_div_factor: forall a b c : nat, c <> 0 -> Nat.divide c a -> Nat.divide c b -> Nat.gcd (a / c) (b / c) = Nat.gcd a b / c
gcd_div_gcd: forall a b g : nat, g <> 0 -> g = Nat.gcd a b -> Nat.gcd (a / g) (b / g) = 1
gcd_div_swap: forall a b : nat, a / Nat.gcd a b * b = a * (b / Nat.gcd a b)
gcd_divide: forall a b : nat, Nat.divide (Nat.gcd a b) a /\ Nat.divide (Nat.gcd a b) b
gcd_divide_iff: forall n m p : nat, Nat.divide p (Nat.gcd n m) <-> Nat.divide p n /\ Nat.divide p m
gcd_divide_l: forall a b : nat, Nat.divide (Nat.gcd a b) a
gcd_divide_r: forall a b : nat, Nat.divide (Nat.gcd a b) b
gcd_eq_0: forall n m : nat, Nat.gcd n m = 0 <-> n = 0 /\ m = 0
gcd_eq_0_l: forall n m : nat, Nat.gcd n m = 0 -> n = 0
gcd_eq_0_r: forall n m : nat, Nat.gcd n m = 0 -> m = 0
gcd_greatest: forall a b c : nat, Nat.divide c a -> Nat.divide c b -> Nat.divide c (Nat.gcd a b)
gcd_mod: forall a b : nat, b <> 0 -> Nat.gcd (a mod b) b = Nat.gcd b a
gcd_mul_diag_l: forall n m : nat, 0 <= n -> Nat.gcd n (n * m) = n
gcd_mul_mono_l: forall n m p : nat, Nat.gcd (p * n) (p * m) = p * Nat.gcd n m
gcd_mul_mono_r: forall n m p : nat, Nat.gcd (n * p) (m * p) = Nat.gcd n m * p
gcd_nonneg: forall a b : nat, 0 <= Nat.gcd a b
gcd_sub_diag_r: forall n m : nat, n <= m -> Nat.gcd n (m - n) = Nat.gcd n m
gcd_unique': forall n m p : nat, Nat.divide p n -> Nat.divide p m -> (forall q : nat, Nat.divide q n -> Nat.divide q m -> Nat.divide q p) -> Nat.gcd n m = p
gcd_unique: forall n m p : nat, 0 <= p -> Nat.divide p n -> Nat.divide p m -> (forall q : nat, Nat.divide q n -> Nat.divide q m -> Nat.divide q p) -> Nat.gcd n m = p
gcd_unique_alt': forall n m p : nat, (forall q : nat, Nat.divide q p <-> Nat.divide q n /\ Nat.divide q m) -> Nat.gcd n m = p
gcd_unique_alt: forall n m p : nat, 0 <= p -> (forall q : nat, Nat.divide q p <-> Nat.divide q n /\ Nat.divide q m) -> Nat.gcd n m = p
gcdn_greatest: forall (n : nat) (a b : BinNums.positive), BinPos.Pos.size_nat a + BinPos.Pos.size_nat b <= n -> forall p : BinNums.positive, BinPos.Pos.divide p a -> BinPos.Pos.divide p b -> BinPos.Pos.divide p (BinPos.Pos.gcdn n a b)
ge_dec: forall n m : nat, {n >= m} + {~ n >= m}
ggcdn_correct_divisors: forall (n : nat) (a b : BinNums.positive), let '(g, (aa, bb)) := BinPos.Pos.ggcdn n a b in a = BinPos.Pos.mul g aa /\ b = BinPos.Pos.mul g bb
ggcdn_gcdn: forall (n : nat) (a b : BinNums.positive), fst (BinPos.Pos.ggcdn n a b) = BinPos.Pos.gcdn n a b

gt_wf: forall z : nat, well_founded (fun n m : nat => m < n <= z)
gt_wf_ind: forall (n : nat) (P : nat -> Prop), (forall n0 : nat, (forall m : nat, n0 > m -> P m) -> P n0) -> P n
gt_wf_rec: forall (n : nat) (P : nat -> Set), (forall n0 : nat, (forall m : nat, n0 > m -> P m) -> P n0) -> P n
gt_wf_rect: forall (n : nat) (P : nat -> Type), (forall n0 : nat, (forall m : nat, n0 > m -> P m) -> P n0) -> P n
gtof: forall A : Type, (A -> nat) -> A -> A -> Prop
id: forall n : nat, BinNat.N.to_nat (BinNat.N.of_nat n) = n
id: forall n : nat, n <> 0 -> BinPos.Pos.to_nat (BinPos.Pos.of_nat n) = n
id_max: forall n : nat, BinPos.Pos.to_nat (BinPos.Pos.of_nat n) = Init.Nat.max 1 n
id_succ: forall n : nat, BinPos.Pos.to_nat (BinPos.Pos.of_succ_nat n) = S n
in_int_between: forall (P : nat -> Prop) (k l : nat), k <= l -> (forall r : nat, in_int k l r -> P r) -> between P k l
in_int_exists: forall (Q : nat -> Prop) (k l r : nat), in_int k l r -> Q r -> exists_between Q k l
in_int_intro: forall p q r : nat, p <= r -> r < q -> in_int p q r
in_int_lt: forall p q r : nat, in_int p q r -> p < q
in_int_p_Sq: forall p q r : nat, in_int p (S q) r -> in_int p q r \/ r = q
in_int_S: forall p q r : nat, in_int p q r -> in_int p (S q) r
in_int_Sp_q: forall p q r : nat, in_int (S p) q r -> in_int p q r
In_nth: forall [A : Type] (l : list A) (x d : A), List.In x l -> exists n : nat, n < Datatypes.length l /\ List.nth n l d = x
In_nth_error: forall [A : Type] (l : list A) (x : A), List.In x l -> exists n : nat, List.nth_error l n = Some x
in_seq: forall len start n : nat, List.In n (List.seq start len) <-> start <= n < start + len
induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> A 0 -> (forall n : nat, A n -> A (S n)) -> forall n : nat, A n
induction_gtof1: forall (A : Type) (f : A -> nat) (P : A -> Type), (forall x : A, (forall y : A, gtof A f y x -> P y) -> P x) -> forall a : A, P a
induction_gtof2: forall (A : Type) (f : A -> nat) (P : A -> Type), (forall x : A, (forall y : A, gtof A f y x -> P y) -> P x) -> forall a : A, P a
induction_ltof1: forall (A : Type) (f : A -> nat) (P : A -> Type), (forall x : A, (forall y : A, ltof A f y x -> P y) -> P x) -> forall a : A, P a
induction_ltof2: forall (A : Type) (f : A -> nat) (P : A -> Type), (forall x : A, (forall y : A, ltof A f y x -> P y) -> P x) -> forall a : A, P a
inj: forall a a' : BinNums.N, BinNat.N.to_nat a = BinNat.N.to_nat a' -> a = a'
inj: forall n m : nat, BinPos.Pos.of_succ_nat n = BinPos.Pos.of_succ_nat m -> n = m
inj: forall n m : nat, n <> 0 -> m <> 0 -> BinPos.Pos.of_nat n = BinPos.Pos.of_nat m -> n = m
inj: forall n n' : nat, BinNat.N.of_nat n = BinNat.N.of_nat n' -> n = n'
inj: forall p q : BinNums.positive, BinPos.Pos.to_nat p = BinPos.Pos.to_nat q -> p = q
inj_add: forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.add a a') = BinNat.N.to_nat a + BinNat.N.to_nat a'
inj_add: forall n m : nat, n <> 0 -> m <> 0 -> BinPos.Pos.of_nat (n + m) = BinPos.Pos.add (BinPos.Pos.of_nat n) (BinPos.Pos.of_nat m)
inj_add: forall n n' : nat, BinNat.N.of_nat (n + n') = BinNat.N.add (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_add: forall p q : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.add p q) = BinPos.Pos.to_nat p + BinPos.Pos.to_nat q
inj_compare: forall n m : nat, (n ?= m) = BinPos.Pos.compare (BinPos.Pos.of_succ_nat n) (BinPos.Pos.of_succ_nat m)
inj_compare: forall n m : nat, n <> 0 -> m <> 0 -> (n ?= m) = BinPos.Pos.compare (BinPos.Pos.of_nat n) (BinPos.Pos.of_nat m)
inj_compare: forall n n' : nat, (n ?= n') = BinNat.N.compare (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_div: forall n m : BinNums.N, BinNat.N.to_nat (BinNat.N.div n m) = BinNat.N.to_nat n / BinNat.N.to_nat m
inj_div: forall n n' : nat, BinNat.N.of_nat (n / n') = BinNat.N.div (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_div2: forall a : BinNums.N, BinNat.N.to_nat (BinNat.N.div2 a) = Nat.div2 (BinNat.N.to_nat a)
inj_div2: forall n : nat, BinNat.N.of_nat (Nat.div2 n) = BinNat.N.div2 (BinNat.N.of_nat n)
inj_double: forall a : BinNums.N, BinNat.N.to_nat (BinNat.N.double a) = 2 * BinNat.N.to_nat a
inj_double: forall n : nat, BinNat.N.of_nat (2 * n) = BinNat.N.double (BinNat.N.of_nat n)
inj_iff: forall a a' : BinNums.N, BinNat.N.to_nat a = BinNat.N.to_nat a' <-> a = a'
inj_iff: forall n m : nat, BinPos.Pos.of_succ_nat n = BinPos.Pos.of_succ_nat m <-> n = m
inj_iff: forall n m : nat, n <> 0 -> m <> 0 -> BinPos.Pos.of_nat n = BinPos.Pos.of_nat m <-> n = m
inj_iff: forall n n' : nat, BinNat.N.of_nat n = BinNat.N.of_nat n' <-> n = n'
inj_iff: forall p q : BinNums.positive, BinPos.Pos.to_nat p = BinPos.Pos.to_nat q <-> p = q
inj_iter: forall (n : nat) {A : Type} (f : A -> A) (x : A), Nat.iter n f x = BinNat.N.iter (BinNat.N.of_nat n) f x
inj_iter: forall (p : BinNums.positive) {A : Type} (f : A -> A) (x : A), BinPos.Pos.iter f x p = nat_rect (fun _ : nat => A) x (fun _ : nat => f) (BinPos.Pos.to_nat p)
inj_max: forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.max a a') = Nat.max (BinNat.N.to_nat a) (BinNat.N.to_nat a')
inj_max: forall n m : nat, BinPos.Pos.of_nat (Init.Nat.max n m) = BinPos.Pos.max (BinPos.Pos.of_nat n) (BinPos.Pos.of_nat m)
inj_max: forall n n' : nat, BinNat.N.of_nat (Nat.max n n') = BinNat.N.max (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_max: forall p q : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.max p q) = Nat.max (BinPos.Pos.to_nat p) (BinPos.Pos.to_nat q)
inj_min: forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.min a a') = Nat.min (BinNat.N.to_nat a) (BinNat.N.to_nat a')
inj_min: forall n m : nat, BinPos.Pos.of_nat (Init.Nat.min n m) = BinPos.Pos.min (BinPos.Pos.of_nat n) (BinPos.Pos.of_nat m)
inj_min: forall n n' : nat, BinNat.N.of_nat (Nat.min n n') = BinNat.N.min (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_min: forall p q : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.min p q) = Nat.min (BinPos.Pos.to_nat p) (BinPos.Pos.to_nat q)
inj_mod: forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.modulo a a') = BinNat.N.to_nat a mod BinNat.N.to_nat a'
inj_mod: forall n n' : nat, BinNat.N.of_nat (n mod n') = BinNat.N.modulo (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_mul: forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.mul a a') = BinNat.N.to_nat a * BinNat.N.to_nat a'
inj_mul: forall n m : nat, n <> 0 -> m <> 0 -> BinPos.Pos.of_nat (n * m) = BinPos.Pos.mul (BinPos.Pos.of_nat n) (BinPos.Pos.of_nat m)
inj_mul: forall n n' : nat, BinNat.N.of_nat (n * n') = BinNat.N.mul (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_mul: forall p q : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.mul p q) = BinPos.Pos.to_nat p * BinPos.Pos.to_nat q
inj_pow: forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.pow a a') = BinNat.N.to_nat a ^ BinNat.N.to_nat a'
inj_pow: forall n m : nat, m <> 0 -> BinPos.Pos.of_nat (n ^ m) = BinPos.Pos.pow (BinPos.Pos.of_nat n) (BinPos.Pos.of_nat m)
inj_pow: forall n n' : nat, BinNat.N.of_nat (n ^ n') = BinNat.N.pow (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_pow: forall p q : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.pow p q) = BinPos.Pos.to_nat p ^ BinPos.Pos.to_nat q
inj_pred: forall a : BinNums.N, BinNat.N.to_nat (BinNat.N.pred a) = Nat.pred (BinNat.N.to_nat a)
inj_pred: forall n : nat, BinNat.N.of_nat (Nat.pred n) = BinNat.N.pred (BinNat.N.of_nat n)
inj_pred: forall n : nat, BinPos.Pos.of_nat (Init.Nat.pred n) = BinPos.Pos.pred (BinPos.Pos.of_nat n)
inj_pred: forall p : BinNums.positive, BinPos.Pos.lt BinNums.xH p -> BinPos.Pos.to_nat (BinPos.Pos.pred p) = Nat.pred (BinPos.Pos.to_nat p)
inj_pred_max: forall p : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.pred p) = Nat.max 1 (Init.Nat.pred (BinPos.Pos.to_nat p))
inj_sub: forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.sub a a') = BinNat.N.to_nat a - BinNat.N.to_nat a'
inj_sub: forall n m : nat, m <> 0 -> BinPos.Pos.of_nat (n - m) = BinPos.Pos.sub (BinPos.Pos.of_nat n) (BinPos.Pos.of_nat m)
inj_sub: forall n n' : nat, BinNat.N.of_nat (n - n') = BinNat.N.sub (BinNat.N.of_nat n) (BinNat.N.of_nat n')
inj_sub: forall p q : BinNums.positive, BinPos.Pos.lt q p -> BinPos.Pos.to_nat (BinPos.Pos.sub p q) = BinPos.Pos.to_nat p - BinPos.Pos.to_nat q
inj_sub_max: forall p q : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.sub p q) = Nat.max 1 (BinPos.Pos.to_nat p - BinPos.Pos.to_nat q)
inj_succ: forall a : BinNums.N, BinNat.N.to_nat (BinNat.N.succ a) = S (BinNat.N.to_nat a)
inj_succ: forall n : nat, BinNat.N.of_nat (S n) = BinNat.N.succ (BinNat.N.of_nat n)
inj_succ: forall n : nat, BinPos.Pos.of_succ_nat (S n) = BinPos.Pos.succ (BinPos.Pos.of_succ_nat n)
inj_succ: forall n : nat, n <> 0 -> BinPos.Pos.of_nat (S n) = BinPos.Pos.succ (BinPos.Pos.of_nat n)
inj_succ: forall p : BinNums.positive, BinPos.Pos.to_nat (BinPos.Pos.succ p) = S (BinPos.Pos.to_nat p)
inj_succ_double: forall a : BinNums.N, BinNat.N.to_nat (BinNat.N.succ_double a) = S (2 * BinNat.N.to_nat a)
inj_succ_double: forall n : nat, BinNat.N.of_nat (S (2 * n)) = BinNat.N.succ_double (BinNat.N.of_nat n)
inj_xI: forall p : BinNums.positive, BinPos.Pos.to_nat (BinNums.xI p) = S (2 * BinPos.Pos.to_nat p)
inj_xO: forall p : BinNums.positive, BinPos.Pos.to_nat (BinNums.xO p) = 2 * BinPos.Pos.to_nat p
inv: forall (n : nat) (p : BinNums.positive), BinPos.Pos.to_nat p = S n -> BinPos.Pos.of_succ_nat n = p
inv_lt_rel: forall A : Set, (A -> nat -> Prop) -> A -> A -> Prop
is_succ: forall p : BinNums.positive, exists n : nat, BinPos.Pos.to_nat p = S n
iter: nat -> forall A : Type, (A -> A) -> A -> A
iter: nat -> forall A : Type, (A -> A) -> A -> A
land_0_l: forall a : nat, Nat.land 0 a = 0
land_0_r: forall a : nat, Nat.land a 0 = 0
land_assoc: forall a b c : nat, Nat.land a (Nat.land b c) = Nat.land (Nat.land a b) c
land_comm: forall a b : nat, Nat.land a b = Nat.land b a
land_diag: forall a : nat, Nat.land a a = a
land_ldiff: forall a b : nat, Nat.land (Nat.ldiff a b) b = 0
land_lnot_diag: forall a n : nat, Nat.land a (Nat.lnot a n) = Nat.ldiff a (Nat.ones n)
land_lnot_diag_low: forall a n : nat, Nat.log2 a < n -> Nat.land a (Nat.lnot a n) = 0
land_lor_distr_l: forall a b c : nat, Nat.land (Nat.lor a b) c = Nat.lor (Nat.land a c) (Nat.land b c)
land_lor_distr_r: forall a b c : nat, Nat.land a (Nat.lor b c) = Nat.lor (Nat.land a b) (Nat.land a c)
land_ones: forall a n : nat, Nat.land a (Nat.ones n) = a mod 2 ^ n
land_ones_low: forall a n : nat, Nat.log2 a < n -> Nat.land a (Nat.ones n) = a
land_spec: forall a b n : nat, Nat.testbit (Nat.land a b) n = (Nat.testbit a n && Nat.testbit b n)%bool
last_length: forall [A : Type] (l : list A) (a : A), Datatypes.length (l ++ a :: Datatypes.nil) = S (Datatypes.length l)
lbase: forall (A : nat -> Prop) (z : nat), (fun n : nat => forall m : nat, m <= z -> n <= m -> A m) (S z)
lcm_0_l: forall n : nat, Nat.lcm 0 n = 0
lcm_0_r: forall n : nat, Nat.lcm n 0 = 0
lcm_1_l: forall n : nat, Nat.lcm 1 n = n
lcm_1_r: forall n : nat, Nat.lcm n 1 = n
lcm_assoc: forall n m p : nat, Nat.lcm n (Nat.lcm m p) = Nat.lcm (Nat.lcm n m) p
lcm_comm: forall a b : nat, Nat.lcm a b = Nat.lcm b a
lcm_diag: forall n : nat, Nat.lcm n n = n
lcm_divide_iff: forall n m p : nat, Nat.divide (Nat.lcm n m) p <-> Nat.divide n p /\ Nat.divide m p
lcm_eq_0: forall n m : nat, Nat.lcm n m = 0 <-> n = 0 \/ m = 0
lcm_equiv1: forall a b : nat, Nat.gcd a b <> 0 -> a * (b / Nat.gcd a b) = a * b / Nat.gcd a b
lcm_equiv2: forall a b : nat, Nat.gcd a b <> 0 -> a / Nat.gcd a b * b = a * b / Nat.gcd a b
lcm_least: forall a b c : nat, Nat.divide a c -> Nat.divide b c -> Nat.divide (Nat.lcm a b) c
lcm_mul_mono_l: forall n m p : nat, Nat.lcm (p * n) (p * m) = p * Nat.lcm n m
lcm_mul_mono_r: forall n m p : nat, Nat.lcm (n * p) (m * p) = Nat.lcm n m * p
lcm_unique: forall n m p : nat, 0 <= p -> Nat.divide n p -> Nat.divide m p -> (forall q : nat, Nat.divide n q -> Nat.divide m q -> Nat.divide p q) -> Nat.lcm n m = p
lcm_unique_alt: forall n m p : nat, 0 <= p -> (forall q : nat, Nat.divide p q <-> Nat.divide n q /\ Nat.divide m q) -> Nat.lcm n m = p
ldiff_0_l: forall a : nat, Nat.ldiff 0 a = 0
ldiff_0_r: forall a : nat, Nat.ldiff a 0 = a
ldiff_diag: forall a : nat, Nat.ldiff a a = 0
ldiff_land_low: forall a b n : nat, Nat.log2 a < n -> Nat.ldiff a b = Nat.land a (Nat.lnot b n)
ldiff_ldiff_l: forall a b c : nat, Nat.ldiff (Nat.ldiff a b) c = Nat.ldiff a (Nat.lor b c)
ldiff_le: forall a b : nat, Nat.ldiff a b = 0 -> a <= b
ldiff_ones_l_low: forall a n : nat, Nat.log2 a < n -> Nat.ldiff (Nat.ones n) a = Nat.lnot a n
ldiff_ones_r: forall a n : nat, Nat.ldiff a (Nat.ones n) = Nat.shiftl (Nat.shiftr a n) n
ldiff_ones_r_low: forall a n : nat, Nat.log2 a < n -> Nat.ldiff a (Nat.ones n) = 0
ldiff_spec: forall a b n : nat, Nat.testbit (Nat.ldiff a b) n = (Nat.testbit a n && negb (Nat.testbit b n))%bool

le_add_le_sub_l: forall n m p : nat, n + p <= m -> p <= m - n
le_add_le_sub_r: forall n m p : nat, n + p <= m -> n <= m - p


leb_antisym: forall x y : nat, (y <=? x) = negb (x <? y)
leb_compare: forall n m : nat, (n <=? m) = true <-> (n ?= m) <> Gt
leb_compare: forall x y : nat, (x <=? y) = match x ?= y with | Gt => false | _ => true end
leb_complete: forall m n : nat, (m <=? n) = true -> m <= n
leb_complete_conv: forall m n : nat, (n <=? m) = false -> m < n
leb_correct: forall m n : nat, m <= n -> (m <=? n) = true
leb_correct_conv: forall m n : nat, m < n -> (n <=? m) = false
leb_gt: forall x y : nat, (x <=? y) = false <-> y < x
leb_iff_conv: forall m n : nat, (n <=? m) = false <-> m < n
leb_le: forall n m : nat, (n <=? m) = true <-> n <= m
leb_nle: forall x y : nat, (x <=? y) = false <-> ~ x <= y
leb_refl: forall x : nat, (x <=? x) = true
leb_spec: forall x y : nat, BoolSpec (x <= y) (y < x) (x <=? y)
leb_spec0: forall x y : nat, Bool.reflect (x <= y) (x <=? y)
left_induction': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, z <= n -> A n) -> (forall n : nat, n < z -> A (S n) -> A n) -> forall n : nat, A n
left_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, A z -> (forall n : nat, n < z -> A (S n) -> A n) -> forall n : nat, n <= z -> A n
length: forall [A : Type], list A -> nat
length_zero_iff_nil: forall [A : Type] (l : list A), Datatypes.length l = 0 <-> l = Datatypes.nil
list_max_app: forall l1 l2 : list nat, List.list_max (l1 ++ l2) = Init.Nat.max (List.list_max l1) (List.list_max l2)
list_max_le: forall (l : list nat) (n : nat), List.list_max l <= n <-> List.Forall (fun k : nat => k <= n) l
list_max_lt: forall [l : list nat] (n : nat), l <> Datatypes.nil -> List.list_max l < n <-> List.Forall (fun k : nat => k < n) l
list_sum_app: forall l1 l2 : list nat, List.list_sum (l1 ++ l2) = List.list_sum l1 + List.list_sum l2
lnot_0_l: forall n : nat, Nat.lnot 0 n = Nat.ones n
lnot_involutive: forall a n : nat, Nat.lnot (Nat.lnot a n) n = a
lnot_land_low: forall a b n : nat, Nat.log2 a < n -> Nat.log2 b < n -> Nat.lnot (Nat.land a b) n = Nat.lor (Nat.lnot a n) (Nat.lnot b n)
lnot_ldiff_low: forall a b n : nat, Nat.log2 a < n -> Nat.log2 b < n -> Nat.lnot (Nat.ldiff a b) n = Nat.lor (Nat.lnot a n) b
lnot_lor_low: forall a b n : nat, Nat.log2 a < n -> Nat.log2 b < n -> Nat.lnot (Nat.lor a b) n = Nat.land (Nat.lnot a n) (Nat.lnot b n)
lnot_lxor_l: forall a b n : nat, Nat.lnot (Nat.lxor a b) n = Nat.lxor (Nat.lnot a n) b
lnot_lxor_r: forall a b n : nat, Nat.lnot (Nat.lxor a b) n = Nat.lxor a (Nat.lnot b n)
lnot_ones: forall n : nat, Nat.lnot (Nat.ones n) n = 0
lnot_spec_high: forall a n m : nat, n <= m -> Nat.testbit (Nat.lnot a n) m = Nat.testbit a m
lnot_spec_low: forall a n m : nat, m < n -> Nat.testbit (Nat.lnot a n) m = negb (Nat.testbit a m)
lnot_sub_low: forall a n : nat, Nat.log2 a < n -> Nat.lnot a n = Nat.ones n - a
log2_add_le: forall a b : nat, a <> 1 -> b <> 1 -> Nat.log2 (a + b) <= Nat.log2 a + Nat.log2 b
log2_bits_unique: forall a n : nat, Nat.testbit a n = true -> (forall m : nat, n < m -> Nat.testbit a m = false) -> Nat.log2 a = n
log2_double: forall a : nat, 0 < a -> Nat.log2 (2 * a) = S (Nat.log2 a)
log2_eq_succ_iff_pow2: forall a : nat, 0 < a -> Nat.log2 (S a) = S (Nat.log2 a) <-> (exists b : nat, S a = 2 ^ b)
log2_eq_succ_is_pow2: forall a : nat, Nat.log2 (S a) = S (Nat.log2 a) -> exists b : nat, S a = 2 ^ b
log2_iter_spec: forall k p q r : nat, 2 ^ S p = q + S r -> r < 2 ^ p -> let s := Nat.log2_iter k p q r in 2 ^ s <= k + q < 2 ^ S s
log2_land: forall a b : nat, Nat.log2 (Nat.land a b) <= Nat.min (Nat.log2 a) (Nat.log2 b)
log2_le_lin: forall a : nat, 0 <= a -> Nat.log2 a <= a
log2_le_mono: forall a b : nat, a <= b -> Nat.log2 a <= Nat.log2 b
log2_le_pow2: forall a b : nat, 0 < a -> 2 ^ b <= a <-> b <= Nat.log2 a
log2_log2_up_exact: forall a : nat, 0 < a -> Nat.log2 a = Nat.log2_up a <-> (exists b : nat, a = 2 ^ b)
log2_log2_up_spec: forall a : nat, 0 < a -> 2 ^ Nat.log2 a <= a <= 2 ^ Nat.log2_up a
log2_lor: forall a b : nat, Nat.log2 (Nat.lor a b) = Nat.max (Nat.log2 a) (Nat.log2 b)
log2_lt_cancel: forall a b : nat, Nat.log2 a < Nat.log2 b -> a < b
log2_lt_lin: forall a : nat, 0 < a -> Nat.log2 a < a
log2_lt_pow2: forall a b : nat, 0 < a -> a < 2 ^ b <-> Nat.log2 a < b
log2_lxor: forall a b : nat, Nat.log2 (Nat.lxor a b) <= Nat.max (Nat.log2 a) (Nat.log2 b)
log2_mul_above: forall a b : nat, 0 <= a -> 0 <= b -> Nat.log2 (a * b) <= Nat.log2 a + Nat.log2 b + 1
log2_mul_below: forall a b : nat, 0 < a -> 0 < b -> Nat.log2 a + Nat.log2 b <= Nat.log2 (a * b)
log2_mul_pow2: forall a b : nat, 0 < a -> 0 <= b -> Nat.log2 (a * 2 ^ b) = b + Nat.log2 a
log2_nonneg: forall a : nat, 0 <= Nat.log2 a
log2_nonpos: forall n : nat, n <= 0 -> Nat.log2 n = 0
log2_null: forall a : nat, Nat.log2 a = 0 <-> a <= 1
log2_pos: forall a : nat, 1 < a -> 0 < Nat.log2 a
log2_pow2: forall a : nat, 0 <= a -> Nat.log2 (2 ^ a) = a
log2_pred_pow2: forall a : nat, 0 < a -> Nat.log2 (Nat.pred (2 ^ a)) = Nat.pred a
log2_same: forall a b : nat, 0 < a -> 0 < b -> Nat.log2 a = Nat.log2 b -> a < 2 * b
log2_shiftl: forall a n : nat, a <> 0 -> Nat.log2 (Nat.shiftl a n) = Nat.log2 a + n
log2_shiftr: forall a n : nat, Nat.log2 (Nat.shiftr a n) = Nat.log2 a - n
log2_spec: forall n : nat, 0 < n -> 2 ^ Nat.log2 n <= n < 2 ^ S (Nat.log2 n)
log2_spec_alt: forall a : nat, 0 < a -> exists r : nat, a = 2 ^ Nat.log2 a + r /\ 0 <= r < 2 ^ Nat.log2 a
log2_succ_double: forall a : nat, 0 < a -> Nat.log2 (2 * a + 1) = S (Nat.log2 a)
log2_succ_le: forall a : nat, Nat.log2 (S a) <= S (Nat.log2 a)
log2_succ_or: forall a : nat, Nat.log2 (S a) = S (Nat.log2 a) \/ Nat.log2 (S a) = Nat.log2 a
log2_unique': forall a b c : nat, 0 <= b -> 0 <= c < 2 ^ b -> a = 2 ^ b + c -> Nat.log2 a = b
log2_unique: forall a b : nat, 0 <= b -> 2 ^ b <= a < 2 ^ S b -> Nat.log2 a = b
log2_up_add_le: forall a b : nat, a <> 1 -> b <> 1 -> Nat.log2_up (a + b) <= Nat.log2_up a + Nat.log2_up b
log2_up_double: forall a : nat, 0 < a -> Nat.log2_up (2 * a) = S (Nat.log2_up a)
log2_up_eq_succ_iff_pow2: forall a : nat, 0 < a -> Nat.log2_up (S a) = S (Nat.log2_up a) <-> (exists b : nat, a = 2 ^ b)
log2_up_eq_succ_is_pow2: forall a : nat, Nat.log2_up (S a) = S (Nat.log2_up a) -> exists b : nat, a = 2 ^ b
log2_up_eqn: forall a : nat, 1 < a -> Nat.log2_up a = S (Nat.log2 (Nat.pred a))
log2_up_eqn0: forall a : nat, a <= 1 -> Nat.log2_up a = 0
log2_up_le_lin: forall a : nat, 0 <= a -> Nat.log2_up a <= a
log2_up_le_mono: forall a b : nat, a <= b -> Nat.log2_up a <= Nat.log2_up b
log2_up_le_pow2: forall a b : nat, 0 < a -> a <= 2 ^ b <-> Nat.log2_up a <= b
log2_up_lt_cancel: forall a b : nat, Nat.log2_up a < Nat.log2_up b -> a < b
log2_up_lt_lin: forall a : nat, 0 < a -> Nat.log2_up a < a
log2_up_lt_pow2: forall a b : nat, 0 < a -> 2 ^ b < a <-> b < Nat.log2_up a
log2_up_mul_above: forall a b : nat, 0 <= a -> 0 <= b -> Nat.log2_up (a * b) <= Nat.log2_up a + Nat.log2_up b
log2_up_mul_below: forall a b : nat, 0 < a -> 0 < b -> Nat.log2_up a + Nat.log2_up b <= S (Nat.log2_up (a * b))
log2_up_mul_pow2: forall a b : nat, 0 < a -> 0 <= b -> Nat.log2_up (a * 2 ^ b) = b + Nat.log2_up a
log2_up_nonneg: forall a : nat, 0 <= Nat.log2_up a
log2_up_nonpos: forall a : nat, a <= 0 -> Nat.log2_up a = 0
log2_up_null: forall a : nat, Nat.log2_up a = 0 <-> a <= 1
log2_up_pos: forall a : nat, 1 < a -> 0 < Nat.log2_up a
log2_up_pow2: forall a : nat, 0 <= a -> Nat.log2_up (2 ^ a) = a
log2_up_same: forall a b : nat, 0 < a -> 0 < b -> Nat.log2_up a = Nat.log2_up b -> a < 2 * b
log2_up_spec: forall a : nat, 1 < a -> 2 ^ Nat.pred (Nat.log2_up a) < a <= 2 ^ Nat.log2_up a
log2_up_succ_double: forall a : nat, 0 < a -> Nat.log2_up (2 * a + 1) = 2 + Nat.log2 a
log2_up_succ_le: forall a : nat, Nat.log2_up (S a) <= S (Nat.log2_up a)
log2_up_succ_or: forall a : nat, Nat.log2_up (S a) = S (Nat.log2_up a) \/ Nat.log2_up (S a) = Nat.log2_up a
log2_up_succ_pow2: forall a : nat, 0 <= a -> Nat.log2_up (S (2 ^ a)) = S a
log2_up_unique: forall a b : nat, 0 < b -> 2 ^ Nat.pred b < a <= 2 ^ b -> Nat.log2_up a = b
lor_0_l: forall a : nat, Nat.lor 0 a = a
lor_0_r: forall a : nat, Nat.lor a 0 = a
lor_assoc: forall a b c : nat, Nat.lor a (Nat.lor b c) = Nat.lor (Nat.lor a b) c
lor_comm: forall a b : nat, Nat.lor a b = Nat.lor b a
lor_diag: forall a : nat, Nat.lor a a = a
lor_eq_0_iff: forall a b : nat, Nat.lor a b = 0 <-> a = 0 /\ b = 0
lor_eq_0_l: forall a b : nat, Nat.lor a b = 0 -> a = 0
lor_land_distr_l: forall a b c : nat, Nat.lor (Nat.land a b) c = Nat.land (Nat.lor a c) (Nat.lor b c)
lor_land_distr_r: forall a b c : nat, Nat.lor a (Nat.land b c) = Nat.land (Nat.lor a b) (Nat.lor a c)
lor_ldiff_and: forall a b : nat, Nat.lor (Nat.ldiff a b) (Nat.land a b) = a
lor_lnot_diag: forall a n : nat, Nat.lor a (Nat.lnot a n) = Nat.lor a (Nat.ones n)
lor_lnot_diag_low: forall a n : nat, Nat.log2 a < n -> Nat.lor a (Nat.lnot a n) = Nat.ones n
lor_ones_low: forall a n : nat, Nat.log2 a < n -> Nat.lor a (Nat.ones n) = Nat.ones n
lor_spec: forall a b n : nat, Nat.testbit (Nat.lor a b) n = (Nat.testbit a n || Nat.testbit b n)%bool
ls'_ls'': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, n <= z -> (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) (S n) -> A n) -> forall n : nat, (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) n <-> (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) (S n)
ls_ls': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, A z -> (forall n : nat, n < z -> A (S n) -> A n) -> forall n : nat, n <= z -> (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) (S n) -> A n

lt_wf: forall z : nat, well_founded (fun n m : nat => z <= n < m)
lt_wf_double_ind: forall P : nat -> nat -> Prop, (forall n m : nat, (forall p q : nat, p < n -> P p q) -> (forall p : nat, p < m -> P n p) -> P n m) -> forall n m : nat, P n m
lt_wf_double_rec: forall P : nat -> nat -> Set, (forall n m : nat, (forall p q : nat, p < n -> P p q) -> (forall p : nat, p < m -> P n p) -> P n m) -> forall n m : nat, P n m
lt_wf_double_rect: forall P : nat -> nat -> Type, (forall n m : nat, (forall p q : nat, p < n -> P p q) -> (forall p : nat, p < m -> P n p) -> P n m) -> forall n m : nat, P n m
lt_wf_ind: forall (n : nat) (P : nat -> Prop), (forall n0 : nat, (forall m : nat, m < n0 -> P m) -> P n0) -> P n
lt_wf_rec: forall (n : nat) (P : nat -> Set), (forall n0 : nat, (forall m : nat, m < n0 -> P m) -> P n0) -> P n
lt_wf_rec1: forall (n : nat) (P : nat -> Set), (forall n0 : nat, (forall m : nat, m < n0 -> P m) -> P n0) -> P n
lt_wf_rect: forall (n : nat) (P : nat -> Type), (forall n0 : nat, (forall m : nat, m < n0 -> P m) -> P n0) -> P n
lt_wf_rect1: forall (n : nat) (P : nat -> Type), (forall n0 : nat, (forall m : nat, m < n0 -> P m) -> P n0) -> P n
ltb_antisym: forall x y : nat, (y <? x) = negb (x <=? y)
ltb_compare: forall x y : nat, (x <? y) = match x ?= y with | Lt => true | _ => false end
ltb_ge: forall x y : nat, (x <? y) = false <-> y <= x
ltb_irrefl: forall x : nat, (x <? x) = false
ltb_lt: forall n m : nat, (n <? m) = true <-> n < m
ltb_nlt: forall x y : nat, (x <? y) = false <-> ~ x < y
ltb_spec: forall x y : nat, BoolSpec (x < y) (y <= x) (x <? y)
ltb_spec0: forall x y : nat, Bool.reflect (x < y) (x <? y)
ltof: forall A : Type, (A -> nat) -> A -> A -> Prop
lxor_0_l: forall a : nat, Nat.lxor 0 a = a
lxor_0_r: forall a : nat, Nat.lxor a 0 = a
lxor_assoc: forall a b c : nat, Nat.lxor (Nat.lxor a b) c = Nat.lxor a (Nat.lxor b c)
lxor_comm: forall a b : nat, Nat.lxor a b = Nat.lxor b a
lxor_eq: forall a a' : nat, Nat.lxor a a' = 0 -> a = a'
lxor_eq_0_iff: forall a a' : nat, Nat.lxor a a' = 0 <-> a = a'
lxor_lnot_lnot: forall a b n : nat, Nat.lxor (Nat.lnot a n) (Nat.lnot b n) = Nat.lxor a b
lxor_lor: forall a b : nat, Nat.land a b = 0 -> Nat.lxor a b = Nat.lor a b
lxor_nilpotent: forall a : nat, Nat.lxor a a = 0
lxor_spec: forall a b n : nat, Nat.testbit (Nat.lxor a b) n = xorb (Nat.testbit a n) (Nat.testbit b n)
map_length: forall [A B : Type] (f : A -> B) (l : list A), Datatypes.length (List.map f l) = Datatypes.length l
map_nth: forall [A B : Type] (f : A -> B) (l : list A) (d : A) (n : nat), List.nth n (List.map f l) (f d) = f (List.nth n l d)
map_nth_error: forall [A B : Type] (f : A -> B) (n : nat) (l : list A) [d : A], List.nth_error l n = Some d -> List.nth_error (List.map f l) n = Some (f d)

minus_diag_reverse: forall n : nat, 0 = n - n
minus_n_O: forall n : nat, n = n - 0
minus_plus: forall n m : nat, n + m - n = m
minus_plus_simpl_l_reverse: forall n m p : nat, n - m = p + n - (p + m)
minus_Sn_m: forall n m : nat, m <= n -> S (n - m) = S n - m
mod_0_l: forall a : nat, a <> 0 -> 0 mod a = 0
mod_1_l: forall a : nat, 1 < a -> 1 mod a = 1
mod_1_r: forall a : nat, a mod 1 = 0
mod_add: forall a b c : nat, c <> 0 -> (a + b * c) mod c = a mod c
mod_bound_pos: forall x y : nat, 0 <= x -> 0 < y -> 0 <= x mod y < y
mod_divide: forall a b : nat, b <> 0 -> a mod b = 0 <-> Nat.divide b a
mod_divides: forall a b : nat, b <> 0 -> a mod b = 0 <-> (exists c : nat, a = b * c)
mod_eq: forall a b : nat, b <> 0 -> a mod b = a - b * (a / b)
mod_le: forall a b : nat, b <> 0 -> a mod b <= a
mod_mod: forall a n : nat, n <> 0 -> (a mod n) mod n = a mod n
mod_mul: forall a b : nat, b <> 0 -> (a * b) mod b = 0
mod_mul_r: forall a b c : nat, b <> 0 -> c <> 0 -> a mod (b * c) = a mod b + b * ((a / b) mod c)
mod_pow2_bits_high: forall a n m : nat, n <= m -> Nat.testbit (a mod 2 ^ n) m = false
mod_pow2_bits_low: forall a n m : nat, m < n -> Nat.testbit (a mod 2 ^ n) m = Nat.testbit a m
mod_same: forall a : nat, a <> 0 -> a mod a = 0
mod_small: forall a b : nat, a < b -> a mod b = a
mod_small_iff: forall a b : nat, b <> 0 -> a mod b = a <-> a < b
mod_unique: forall a b q r : nat, r < b -> a = b * q + r -> r = a mod b
mod_upper_bound: forall a b : nat, b <> 0 -> a mod b < b

mul_mod: forall a b n : nat, n <> 0 -> (a * b) mod n = (a mod n * (b mod n)) mod n
mul_mod_distr_l: forall a b c : nat, b <> 0 -> c <> 0 -> (c * a) mod (c * b) = c * (a mod b)
mul_mod_distr_r: forall a b c : nat, b <> 0 -> c <> 0 -> (a * c) mod (b * c) = a mod b * c
mul_mod_idemp_l: forall a b n : nat, n <> 0 -> (a mod n * b) mod n = (a * b) mod n
mul_mod_idemp_r: forall a b n : nat, n <> 0 -> (a * (b mod n)) mod n = (a * b) mod n
mul_neg_neg: forall n m : nat, n < 0 -> m < 0 -> 0 < n * m
mul_neg_pos: forall n m : nat, n < 0 -> 0 < m -> n * m < 0
mul_nonneg_cancel_l: forall n m : nat, 0 < n -> 0 <= n * m <-> 0 <= m
mul_nonneg_cancel_r: forall n m : nat, 0 < m -> 0 <= n * m <-> 0 <= n
mul_nonneg_nonneg: forall n m : nat, 0 <= n -> 0 <= m -> 0 <= n * m
mul_pos_cancel_l: forall n m : nat, 0 < n -> 0 < n * m <-> 0 < m
mul_pos_cancel_r: forall n m : nat, 0 < m -> 0 < n * m <-> 0 < n
mul_pos_neg: forall n m : nat, 0 < n -> m < 0 -> n * m < 0
mul_pos_pos: forall n m : nat, 0 < n -> 0 < m -> 0 < n * m
mul_pow2_bits_add: forall a n m : nat, Nat.testbit (a * 2 ^ n) (m + n) = Nat.testbit a m
mul_pow2_bits_high: forall a n m : nat, n <= m -> Nat.testbit (a * 2 ^ n) m = Nat.testbit a (m - n)
mul_pow2_bits_low: forall a n m : nat, m < n -> Nat.testbit (a * 2 ^ n) m = false
mul_pred_r: forall n m : nat, n * Nat.pred m = n * m - n
mul_shuffle0: forall n m p : nat, n * m * p = n * p * m
mul_shuffle1: forall n m p q : nat, n * m * (p * q) = n * p * (m * q)
mul_shuffle2: forall n m p q : nat, n * m * (p * q) = n * q * (m * p)
mul_shuffle3: forall n m p : nat, n * (m * p) = m * (n * p)
mul_sub_distr_l: forall n m p : nat, p * (n - m) = p * n - p * m
mul_sub_distr_r: forall n m p : nat, (n - m) * p = n * p - m * p
mul_succ_div_gt: forall a b : nat, b <> 0 -> a < b * S (a / b)

mult_acc_aux: forall n m p : nat, m + n * p = mult_acc m p n
mult_assoc_reverse: forall n m p : nat, n * m * p = n * (m * p)

mult_tail_mult: forall n m : nat, n * m = tail_mult n m
n_Sn: forall n : nat, n <> S n
n_SSn: forall n : nat, n <> S (S n)
n_SSSn: forall n : nat, n <> S (S (S n))
n_SSSSn: forall n : nat, n <> S (S (S (S n)))
nat_case: forall (n : nat) (P : nat -> Prop), P 0 -> (forall m : nat, P (S m)) -> P n
nat_compare_eq: forall n m : nat, (n ?= m) = Eq -> n = m
nat_compare_equiv: forall n m : nat, (n ?= m) = nat_compare_alt n m
nat_compare_ge: forall n m : nat, n >= m <-> (n ?= m) <> Lt
nat_compare_gt: forall n m : nat, n > m <-> (n ?= m) = Gt
nat_compare_Gt_gt: forall n m : nat, (n ?= m) = Gt -> n > m
nat_compare_le: forall n m : nat, n <= m <-> (n ?= m) <> Gt
nat_compare_lt: forall n m : nat, n < m <-> (n ?= m) = Lt
nat_compare_Lt_lt: forall n m : nat, (n ?= m) = Lt -> n < m
nat_double_ind: forall R : nat -> nat -> Prop, (forall n : nat, R 0 n) -> (forall n : nat, R (S n) 0) -> (forall n m : nat, R n m -> R (S n) (S m)) -> forall n m : nat, R n m
nat_ind: forall P : nat -> Prop, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
nat_of_P_minus_morphism: forall p q : BinNums.positive, BinPos.Pos.compare_cont Eq p q = Gt -> BinPos.Pos.to_nat (BinPos.Pos.sub p q) = BinPos.Pos.to_nat p - BinPos.Pos.to_nat q
nat_rec: forall P : nat -> Set, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
nat_rect: forall P : nat -> Type, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
nat_rect_plus: forall (n m : nat) {A : Type} (f : A -> A) (x : A), nat_rect (fun _ : nat => A) x (fun _ : nat => f) (n + m) = nat_rect (fun _ : nat => A) (nat_rect (fun _ : nat => A) x (fun _ : nat => f) m) (fun _ : nat => f) n
nat_rect_succ_r: forall {A : Type} (f : A -> A) (x : A) (n : nat), nat_rect (fun _ : nat => A) x (fun _ : nat => f) (S n) = nat_rect (fun _ : nat => A) (f x) (fun _ : nat => f) n
nat_sind: forall P : nat -> SProp, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
nat_total_order: forall n m : nat, n <> m -> n < m \/ m < n
natr_ring_lemma1: forall (n : nat) (l : list nat) (lpe : list (Ring_polynom.PExpr BinNums.N * Ring_polynom.PExpr BinNums.N)) (pe1 pe2 : Ring_polynom.PExpr BinNums.N), Ring_polynom.interp_PElist 0 1 Init.Nat.add Init.Nat.mul (SRsub Init.Nat.add) (SRopp (R:=nat)) eq BinNat.N.to_nat id_phi_N (pow_N 1 Init.Nat.mul) l lpe -> (let lmp := Ring_polynom.mk_monpol_list BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.add BinNat.N.mul BinNat.N.add (fun x : BinNums.N => x) BinNat.N.eqb BinNat.N.div_eucl lpe in Ring_polynom.Peq BinNat.N.eqb (Ring_polynom.norm_subst BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.add BinNat.N.mul BinNat.N.add (fun x : BinNums.N => x) BinNat.N.eqb BinNat.N.div_eucl n lmp pe1) (Ring_polynom.norm_subst BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.add BinNat.N.mul BinNat.N.add (fun x : BinNums.N => x) BinNat.N.eqb BinNat.N.div_eucl n lmp pe2)) = true -> Ring_polynom.PEeval 0 1 Init.Nat.add Init.Nat.mul (SRsub Init.Nat.add) (SRopp (R:=nat)) BinNat.N.to_nat id_phi_N (pow_N 1 Init.Nat.mul) l pe1 = Ring_polynom.PEeval 0 1 Init.Nat.add Init.Nat.mul (SRsub Init.Nat.add) (SRopp (R:=nat)) BinNat.N.to_nat id_phi_N (pow_N 1 Init.Nat.mul) l pe2
natr_ring_lemma2: forall (n : nat) (lH : list (Ring_polynom.PExpr BinNums.N * Ring_polynom.PExpr BinNums.N)) (l : list nat), Ring_polynom.interp_PElist 0 1 Init.Nat.add Init.Nat.mul (SRsub Init.Nat.add) (SRopp (R:=nat)) eq BinNat.N.to_nat id_phi_N (pow_N 1 Init.Nat.mul) l lH -> forall lmp : list (BinNums.N * Ring_polynom.Mon * Ring_polynom.Pol BinNums.N), Ring_polynom.mk_monpol_list BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.add BinNat.N.mul BinNat.N.add (fun x : BinNums.N => x) BinNat.N.eqb BinNat.N.div_eucl lH = lmp -> forall (pe : Ring_polynom.PExpr BinNums.N) (npe : Ring_polynom.Pol BinNums.N), Ring_polynom.norm_subst BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.add BinNat.N.mul BinNat.N.add (fun x : BinNums.N => x) BinNat.N.eqb BinNat.N.div_eucl n lmp pe = npe -> Ring_polynom.PEeval 0 1 Init.Nat.add Init.Nat.mul (SRsub Init.Nat.add) (SRopp (R:=nat)) BinNat.N.to_nat id_phi_N (pow_N 1 Init.Nat.mul) l pe = Ring_polynom.Pphi_dev 0 1 Init.Nat.add Init.Nat.mul (SRsub Init.Nat.add) (SRopp (R:=nat)) BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.eqb BinNat.N.to_nat (get_sign_None (C:=BinNums.N)) l npe
negb_even: forall n : nat, negb (Nat.even n) = Nat.odd n
negb_odd: forall n : nat, negb (Nat.odd n) = Nat.even n
neq_0: ~ (forall n : nat, n = 0)
neq_0_lt: forall n : nat, 0 <> n -> 0 < n
neq_0_lt_0: forall n : nat, n <> 0 <-> 0 < n
neq_0_r: forall n : nat, n <> 0 <-> (exists m : nat, n = S m)
neq_0_succ: forall n : nat, 0 <> S n
neq_mul_0: forall n m : nat, n <> 0 /\ m <> 0 <-> n * m <> 0
neq_succ_0: forall n : nat, S n <> 0
neq_succ_diag_l: forall n : nat, S n <> n
neq_succ_diag_r: forall n : nat, n <> S n
neq_sym: forall n m : nat, n <> m -> m <> n
nle_gt: forall n m : nat, ~ n <= m <-> m < n
nle_succ_0: forall n : nat, ~ S n <= 0
nle_succ_diag_l: forall n : nat, ~ S n <= n
nlt_0_r: forall n : nat, ~ n < 0
nlt_ge: forall n m : nat, ~ n < m <-> m <= n
nlt_succ_diag_l: forall n : nat, ~ S n < n
nlt_succ_r: forall n m : nat, ~ m < S n <-> n < m
nocarry_equiv: forall a b c : nat, c / 2 = Nat.lor (Nat.land a b) (Nat.land c (Nat.lor a b)) -> Nat.testbit c 0 = false -> c = 0 <-> Nat.land a b = 0
NoDup_count_occ': forall [A : Type] (decA : forall x y : A, {x = y} + {x <> y}) (l : list A), List.NoDup l <-> (forall x : A, List.In x l -> List.count_occ decA l x = 1)
NoDup_nth: forall [A : Type] (l : list A) (d : A), List.NoDup l <-> (forall i j : nat, i < Datatypes.length l -> j < Datatypes.length l -> List.nth i l d = List.nth j l d -> i = j)
NoDup_nth_error: forall [A : Type] (l : list A), List.NoDup l <-> (forall i j : nat, i < Datatypes.length l -> List.nth_error l i = List.nth_error l j -> i = j)
norm_subst: forall [C : Type], C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> C) -> (C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> nat -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> Ring_polynom.PExpr C -> Ring_polynom.Pol C
norm_subst_ok: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall (Cpow : Type) (Cp_phi : BinNums.N -> Cpow) (rpow : R -> Cpow -> R), power_theory rI rmul req Cp_phi rpow -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (n : nat) (l : list R) (lpe : list (Ring_polynom.PExpr C * Ring_polynom.PExpr C)) (pe : Ring_polynom.PExpr C), Ring_polynom.interp_PElist rO rI radd rmul rsub ropp req phi Cp_phi rpow l lpe -> req (Ring_polynom.PEeval rO rI radd rmul rsub ropp phi Cp_phi rpow l pe) (Ring_polynom.Pphi rO radd rmul phi l (Ring_polynom.norm_subst cO cI cadd cmul csub copp ceqb cdiv n (Ring_polynom.mk_monpol_list cO cI cadd cmul csub copp ceqb cdiv lpe) pe))
norm_subst_spec: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall (Cpow : Type) (Cp_phi : BinNums.N -> Cpow) (rpow : R -> Cpow -> R), power_theory rI rmul req Cp_phi rpow -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (n : nat) (lmp : list (C * Ring_polynom.Mon * Ring_polynom.Pol C)) (l : list R) (pe : Ring_polynom.PExpr C), Ring_polynom.MPcond rO rI radd rmul req phi lmp l -> req (Ring_polynom.PEeval rO rI radd rmul rsub ropp phi Cp_phi rpow l pe) (Ring_polynom.Pphi rO radd rmul phi l (Ring_polynom.norm_subst cO cI cadd cmul csub copp ceqb cdiv n lmp pe))
not_eq: forall n m : nat, n <> m -> n < m \/ m < n
not_eq_S: forall n m : nat, n <> m -> S n <> S m
not_ge: forall n m : nat, ~ n >= m -> n < m
not_gt: forall n m : nat, ~ n > m -> n <= m
not_le: forall n m : nat, ~ n <= m -> n > m
not_le_minus_0: forall n m : nat, ~ m <= n -> n - m = 0
not_lt: forall n m : nat, ~ n < m -> n >= m
nth: forall [A : Type], nat -> list A -> A -> A
nth_default: forall [A : Type], A -> list A -> nat -> A
nth_default_eq: forall [A : Type] (n : nat) (l : list A) (d : A), List.nth_default d l n = List.nth n l d
nth_error: forall [A : Type], list A -> nat -> option A
nth_error_app1: forall [A : Type] (l l' : list A) [n : nat], n < Datatypes.length l -> List.nth_error (l ++ l') n = List.nth_error l n
nth_error_app2: forall [A : Type] (l l' : list A) [n : nat], Datatypes.length l <= n -> List.nth_error (l ++ l') n = List.nth_error l' (n - Datatypes.length l)
nth_error_In: forall [A : Type] (l : list A) (n : nat) [x : A], List.nth_error l n = Some x -> List.In x l
nth_error_map: forall [A B : Type] (f : A -> B) (n : nat) (l : list A), List.nth_error (List.map f l) n = option_map f (List.nth_error l n)
nth_error_None: forall [A : Type] (l : list A) (n : nat), List.nth_error l n = Datatypes.None <-> Datatypes.length l <= n
nth_error_nth': forall [A : Type] (l : list A) [n : nat] (d : A), n < Datatypes.length l -> List.nth_error l n = Some (List.nth n l d)
nth_error_nth: forall [A : Type] (l : list A) (n : nat) [x : A] (d : A), List.nth_error l n = Some x -> List.nth n l d = x
nth_error_repeat: forall [A : Type] (a : A) [m n : nat], n < m -> List.nth_error (List.repeat a m) n = Some a
nth_error_Some: forall [A : Type] (l : list A) (n : nat), List.nth_error l n <> Datatypes.None <-> n < Datatypes.length l
nth_error_split: forall [A : Type] (l : list A) (n : nat) [a : A], List.nth_error l n = Some a -> exists l1 l2 : list A, l = (l1 ++ a :: l2)%list /\ Datatypes.length l1 = n
nth_ext: forall [A : Type] (l l' : list A) (d d' : A), Datatypes.length l = Datatypes.length l' -> (forall n : nat, n < Datatypes.length l -> List.nth n l d = List.nth n l' d') -> l = l'
nth_In: forall [A : Type] [n : nat] (l : list A) (d : A), n < Datatypes.length l -> List.In (List.nth n l d) l
nth_in_or_default: forall [A : Type] (n : nat) (l : list A) (d : A), {List.In (List.nth n l d) l} + {List.nth n l d = d}
nth_indep: forall [A : Type] (l : list A) [n : nat] (d d' : A), n < Datatypes.length l -> List.nth n l d = List.nth n l d'
nth_le: forall (P Q : nat -> Prop) (init l n : nat), P_nth P Q init l n -> init <= l
nth_nth_nth_map: forall [A : Type] (l : list A) [n : nat] (d : A) (ln : list nat) [dn : nat], n < Datatypes.length ln \/ Datatypes.length l <= dn -> List.nth (List.nth n ln dn) l d = List.nth n (List.map (fun x : nat => List.nth x l d) ln) d
nth_O: forall (P Q : nat -> Prop) (init : nat), P_nth P Q init init 0
nth_ok: forall [A : Type], nat -> list A -> A -> bool
nth_overflow: forall [A : Type] (l : list A) [n : nat] (d : A), Datatypes.length l <= n -> List.nth n l d = d
nth_repeat: forall [A : Type] (a : A) (m n : nat), List.nth n (List.repeat a m) a = a
nth_S: forall (P Q : nat -> Prop) (init k l n : nat), P_nth P Q init k n -> between P (S k) l -> Q l -> P_nth P Q init l (S n)
nth_S_cons: forall [A : Type] (n : nat) (l : list A) (d a : A), List.In (List.nth n l d) l -> List.In (List.nth (S n) (a :: l) d) (a :: l)
nth_split: forall [A : Type] [n : nat] (l : list A) (d : A), n < Datatypes.length l -> exists l1 l2 : list A, l = (l1 ++ List.nth n l d :: l2)%list /\ Datatypes.length l1 = n
O_or_S: forall n : nat, {m : nat | S m = n} + {0 = n}
O_S: forall n : nat, 0 <> S n
odd_add: forall n m : nat, Nat.odd (n + m) = xorb (Nat.odd n) (Nat.odd m)
odd_add_even: forall n m : nat, Nat.Even m -> Nat.odd (n + m) = Nat.odd n
odd_add_mul_2: forall n m : nat, Nat.odd (n + 2 * m) = Nat.odd n
odd_add_mul_even: forall n m p : nat, Nat.Even m -> Nat.odd (n + m * p) = Nat.odd n
odd_bitwise: forall (op : bool -> bool -> bool) (n a b : nat), Nat.odd (Nat.bitwise op (S n) a b) = op (Nat.odd a) (Nat.odd b)
odd_even_lem: forall p q : nat, 2 * p + 1 <> 2 * q
odd_mul: forall n m : nat, Nat.odd (n * m) = (Nat.odd n && Nat.odd m)%bool
odd_pow: forall a b : nat, b <> 0 -> Nat.odd (a ^ b) = Nat.odd a
odd_pred: forall n : nat, n <> 0 -> Nat.odd (Nat.pred n) = Nat.even n
odd_spec: forall n : nat, Nat.odd n = true <-> Nat.Odd n
odd_sub: forall n m : nat, m <= n -> Nat.odd (n - m) = xorb (Nat.odd n) (Nat.odd m)
Odd_succ: forall n : nat, Nat.Odd (S n) <-> Nat.Even n
odd_succ: forall n : nat, Nat.odd (S n) = Nat.even n
Odd_succ_succ: forall n : nat, Nat.Odd (S (S n)) <-> Nat.Odd n
odd_succ_succ: forall n : nat, Nat.odd (S (S n)) = Nat.odd n
of_nat_succ: forall n : nat, BinPos.Pos.of_succ_nat n = BinPos.Pos.of_nat (S n)
ones_add: forall n m : nat, Nat.ones (m + n) = 2 ^ m * Nat.ones n + Nat.ones m
ones_div_pow2: forall n m : nat, m <= n -> Nat.ones n / 2 ^ m = Nat.ones (n - m)
ones_equiv: forall n : nat, Nat.ones n = Nat.pred (2 ^ n)
ones_mod_pow2: forall n m : nat, m <= n -> Nat.ones n mod 2 ^ m = Nat.ones m
ones_spec_high: forall n m : nat, n <= m -> Nat.testbit (Nat.ones n) m = false
ones_spec_iff: forall n m : nat, Nat.testbit (Nat.ones n) m = true <-> m < n
ones_spec_low: forall n m : nat, m < n -> Nat.testbit (Nat.ones n) m = true
orb_even_odd: forall n : nat, (Nat.even n || Nat.odd n)%bool = true
order_induction': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, A z -> (forall n : nat, z <= n -> A n -> A (S n)) -> (forall n : nat, n <= z -> A n -> A (Nat.pred n)) -> forall n : nat, A n
order_induction'_0: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> A 0 -> (forall n : nat, 0 <= n -> A n -> A (S n)) -> (forall n : nat, n <= 0 -> A n -> A (Nat.pred n)) -> forall n : nat, A n
order_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, A z -> (forall n : nat, z <= n -> A n -> A (S n)) -> (forall n : nat, n < z -> A (S n) -> A n) -> forall n : nat, A n
order_induction_0: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> A 0 -> (forall n : nat, 0 <= n -> A n -> A (S n)) -> (forall n : nat, n < 0 -> A (S n) -> A n) -> forall n : nat, A n
P_nth_ind: forall (P Q : nat -> Prop) (init : nat) (P0 : nat -> nat -> Prop), P0 init 0 -> (forall k l n : nat, P_nth P Q init k n -> P0 k n -> between P (S k) l -> Q l -> P0 l (S n)) -> forall n n0 : nat, P_nth P Q init n n0 -> P0 n n0
P_nth_sind: forall (P Q : nat -> Prop) (init : nat) (P0 : nat -> nat -> SProp), P0 init 0 -> (forall k l n : nat, P_nth P Q init k n -> P0 k n -> between P (S k) l -> Q l -> P0 l (S n)) -> forall n n0 : nat, P_nth P Q init n n0 -> P0 n n0
pair_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> A 0 -> A 1 -> (forall n : nat, A n -> A (S n) -> A (S (S n))) -> forall n : nat, A n
Params: forall {A : Type}, A -> nat -> Prop
Params: forall {A : Type}, A -> nat -> Prop
partition_length: forall [A : Type] (f : A -> bool) (l : list A) [l1 l2 : list A], List.partition f l = (l1, l2) -> Datatypes.length l = Datatypes.length l1 + Datatypes.length l2
plus_assoc_reverse: forall n m p : nat, n + m + p = n + (m + p)
plus_gt_compat_l: forall n m p : nat, n > m -> p + n > p + m
plus_gt_reg_l: forall n m p : nat, p + n > p + m -> n > m
plus_is_O: forall n m : nat, n + m = 0 -> n = 0 /\ m = 0
plus_is_one: forall m n : nat, m + n = 1 -> {m = 0 /\ n = 1} + {m = 1 /\ n = 0}
plus_le_compat: forall n m p q : nat, n <= m -> p <= q -> n + p <= m + q
plus_le_compat_l: forall n m p : nat, n <= m -> p + n <= p + m
plus_le_compat_r: forall n m p : nat, n <= m -> n + p <= m + p
plus_le_lt_compat: forall n m p q : nat, n <= m -> p < q -> n + p < m + q
plus_le_reg_l: forall n m p : nat, p + n <= p + m -> n <= m
plus_lt_compat: forall n m p q : nat, n < m -> p < q -> n + p < m + q
plus_lt_compat_l: forall n m p : nat, n < m -> p + n < p + m
plus_lt_compat_r: forall n m p : nat, n < m -> n + p < m + p
plus_lt_le_compat: forall n m p q : nat, n < m -> p <= q -> n + p < m + q
plus_lt_reg_l: forall n m p : nat, p + n < p + m -> n < m
plus_minus: forall n m p : nat, n = m + p -> p = n - m
plus_n_O: forall n : nat, n = n + 0
plus_n_Sm: forall n m : nat, S (n + m) = n + S m
plus_O_n: forall n : nat, 0 + n = n
plus_reg_l: forall n m p : nat, p + n = p + m -> n = m
plus_Sn_m: forall n m : nat, S n + m = S (n + m)
plus_Snm_nSm: forall n m : nat, S n + m = n + S m
plus_tail_plus: forall n m : nat, n + m = tail_plus n m
Pmult_nat_l_plus_morphism: forall (p q : BinNums.positive) (n : nat), BinPos.Pos.iter_op Init.Nat.add (BinPos.Pos.add p q) n = BinPos.Pos.iter_op Init.Nat.add p n + BinPos.Pos.iter_op Init.Nat.add q n
Pmult_nat_mult: forall (p : BinNums.positive) (n : nat), BinPos.Pos.iter_op Init.Nat.add p n = BinPos.Pos.to_nat p * n
Pmult_nat_plus_carry_morphism: forall (p q : BinNums.positive) (n : nat), BinPos.Pos.iter_op Init.Nat.add (BinPos.Pos.add_carry p q) n = n + BinPos.Pos.iter_op Init.Nat.add (BinPos.Pos.add p q) n
Pmult_nat_r_plus_morphism: forall (p : BinNums.positive) (n : nat), BinPos.Pos.iter_op Init.Nat.add p (n + n) = BinPos.Pos.iter_op Init.Nat.add p n + BinPos.Pos.iter_op Init.Nat.add p n
Pmult_nat_succ_morphism: forall (p : BinNums.positive) (n : nat), BinPos.Pos.iter_op Init.Nat.add (BinPos.Pos.succ p) n = n + BinPos.Pos.iter_op Init.Nat.add p n
PNSubst: forall [C : Type], C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> C * Ring_polynom.Mon -> Ring_polynom.Pol C -> nat -> option (Ring_polynom.Pol C)
PNSubst_ok: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (n : nat) (P1 : Ring_polynom.Pol C) (cM1 : C * Ring_polynom.Mon) (P2 : Ring_polynom.Pol C) (l : list R) (P3 : Ring_polynom.Pol C), Ring_polynom.PNSubst cO cI cadd cmul ceqb cdiv P1 cM1 P2 n = Some P3 -> req (rmul (phi (fst cM1)) (Ring_polynom.Mphi rO rI rmul l (snd cM1))) (Ring_polynom.Pphi rO radd rmul phi l P2) -> req (Ring_polynom.Pphi rO radd rmul phi l P1) (Ring_polynom.Pphi rO radd rmul phi l P3)
PNSubst1: forall [C : Type], C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> C * Ring_polynom.Mon -> Ring_polynom.Pol C -> nat -> Ring_polynom.Pol C
PNSubst1_ok: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (n : nat) (P1 : Ring_polynom.Pol C) (cM1 : C * Ring_polynom.Mon) (P2 : Ring_polynom.Pol C) (l : list R), req (rmul (phi (fst cM1)) (Ring_polynom.Mphi rO rI rmul l (snd cM1))) (Ring_polynom.Pphi rO radd rmul phi l P2) -> req (Ring_polynom.Pphi rO radd rmul phi l P1) (Ring_polynom.Pphi rO radd rmul phi l (Ring_polynom.PNSubst1 cO cI cadd cmul ceqb cdiv P1 cM1 P2 n))
PNSubstL: forall [C : Type], C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> nat -> nat -> Ring_polynom.Pol C
PNSubstL_ok: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (m n : nat) (LM1 : list (C * Ring_polynom.Mon * Ring_polynom.Pol C)) (P1 : Ring_polynom.Pol C) (l : list R), Ring_polynom.MPcond rO rI radd rmul req phi LM1 l -> req (Ring_polynom.Pphi rO radd rmul phi l P1) (Ring_polynom.Pphi rO radd rmul phi l (Ring_polynom.PNSubstL cO cI cadd cmul ceqb cdiv P1 LM1 m n))

pow2_bits_eqb: forall n m : nat, Nat.testbit (2 ^ n) m = (n =? m)
pow2_bits_false: forall n m : nat, n <> m -> Nat.testbit (2 ^ n) m = false
pow2_bits_true: forall n : nat, Nat.testbit (2 ^ n) n = true
pred_id: forall n : nat, Init.Nat.pred (BinPos.Pos.to_nat (BinPos.Pos.of_succ_nat n)) = n
pred_inj: forall n m : nat, n <> 0 -> m <> 0 -> Nat.pred n = Nat.pred m -> n = m
pred_le_mono: forall n m : nat, n <= m -> Nat.pred n <= Nat.pred m
pred_lt_mono: forall n m : nat, n <> 0 -> n < m <-> Nat.pred n < Nat.pred m
pred_of_minus: forall n : nat, Init.Nat.pred n = n - 1
pred_of_succ_nat: forall n : nat, BinPos.Pos.pred (BinPos.Pos.of_succ_nat n) = BinPos.Pos.of_nat n
pred_Sn: forall n : nat, n = Init.Nat.pred (S n)
pred_succ: forall n : nat, Nat.pred (S n) = n
prod_length: forall [A B : Type] (l : list A) (l' : list B), Datatypes.length (List.list_prod l l') = Datatypes.length l * Datatypes.length l'
PSubstL: forall [C : Type], C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> nat -> option (Ring_polynom.Pol C)
PSubstL_ok: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (n : nat) (LM1 : list (C * Ring_polynom.Mon * Ring_polynom.Pol C)) (P1 P2 : Ring_polynom.Pol C) (l : list R), Ring_polynom.PSubstL cO cI cadd cmul ceqb cdiv P1 LM1 n = Some P2 -> Ring_polynom.MPcond rO rI radd rmul req phi LM1 l -> req (Ring_polynom.Pphi rO radd rmul phi l P1) (Ring_polynom.Pphi rO radd rmul phi l P2)
PSubstL1: forall [C : Type], C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> nat -> Ring_polynom.Pol C
PSubstL1_ok: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (n : nat) (LM1 : list (C * Ring_polynom.Mon * Ring_polynom.Pol C)) (P1 : Ring_polynom.Pol C) (l : list R), Ring_polynom.MPcond rO rI radd rmul req phi LM1 l -> req (Ring_polynom.Pphi rO radd rmul phi l P1) (Ring_polynom.Pphi rO radd rmul phi l (Ring_polynom.PSubstL1 cO cI cadd cmul ceqb cdiv P1 LM1 n))
quadmul_le_squareadd: forall a b : nat, 0 <= a -> 0 <= b -> 2 * 2 * a * b <= (a + b) * (a + b)
rbase: forall (A : nat -> Prop) (z : nat), (fun n : nat => forall m : nat, z <= m -> m < n -> A m) z
recursion: forall {A : Type}, A -> (nat -> A -> A) -> nat -> A
recursion_0: forall {A : Type} (a : A) (f : nat -> A -> A), Nat.recursion a f 0 = a
recursion_succ: forall {A : Type} (Aeq : Relation_Definitions.relation A) (a : A) (f : nat -> A -> A), Aeq a a -> Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful Aeq Aeq)) f -> forall n : nat, Aeq (Nat.recursion a f (S n)) (f n (Nat.recursion a f n))
recursion_wd: forall {A : Type} (Aeq : Relation_Definitions.relation A), Morphisms.Proper (Morphisms.respectful Aeq (Morphisms.respectful (Morphisms.respectful eq (Morphisms.respectful Aeq Aeq)) (Morphisms.respectful eq Aeq))) Nat.recursion
removelast_firstn: forall [A : Type] [n : nat] (l : list A), n < Datatypes.length l -> List.removelast (List.firstn (S n) l) = List.firstn n l
repeat: forall [A : Type], A -> nat -> list A
repeat_app: forall [A : Type] (x : A) (n m : nat), List.repeat x (n + m) = (List.repeat x n ++ List.repeat x m)%list
repeat_cons: forall [A : Type] (n : nat) (a : A), (a :: List.repeat a n)%list = (List.repeat a n ++ a :: Datatypes.nil)%list
repeat_eq_app: forall [A : Type] (x : A) (n : nat) (l1 l2 : list A), List.repeat x n = (l1 ++ l2)%list -> List.repeat x (Datatypes.length l1) = l1 /\ List.repeat x (Datatypes.length l2) = l2
repeat_eq_cons: forall [A : Type] (x : A) [y : A] (n : nat) [l : list A], List.repeat x n = (y :: l)%list -> x = y /\ List.repeat x (Init.Nat.pred n) = l
repeat_eq_elt: forall [A : Type] (x y : A) (n : nat) (l1 l2 : list A), List.repeat x n = (l1 ++ y :: l2)%list -> x = y /\ List.repeat x (Datatypes.length l1) = l1 /\ List.repeat x (Datatypes.length l2) = l2
repeat_length: forall [A : Type] (x : A) (n : nat), Datatypes.length (List.repeat x n) = n
repeat_spec: forall [A : Type] (n : nat) (x y : A), List.In y (List.repeat x n) -> y = x
repeat_to_concat: forall [A : Type] (n : nat) (a : A), List.repeat a n = List.concat (List.repeat (a :: Datatypes.nil)%list n)
rev_length: forall [A : Type] (l : list A), Datatypes.length (List.rev l) = Datatypes.length l
rev_nth: forall [A : Type] (l : list A) (d : A) [n : nat], n < Datatypes.length l -> List.nth n (List.rev l) d = List.nth (Datatypes.length l - S n) l d
Rgt_wd: forall z : nat, Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff)) (fun n m : nat => m < n <= z)
right_induction': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, n <= z -> A n) -> (forall n : nat, z <= n -> A n -> A (S n)) -> forall n : nat, A n
right_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, A z -> (forall n : nat, z <= n -> A n -> A (S n)) -> forall n : nat, z <= n -> A n
ring_correct: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall (Cpow : Type) (Cp_phi : BinNums.N -> Cpow) (rpow : R -> Cpow -> R), power_theory rI rmul req Cp_phi rpow -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall (n : nat) (l : list R) (lpe : list (Ring_polynom.PExpr C * Ring_polynom.PExpr C)) (pe1 pe2 : Ring_polynom.PExpr C), Ring_polynom.interp_PElist rO rI radd rmul rsub ropp req phi Cp_phi rpow l lpe -> (let lmp := Ring_polynom.mk_monpol_list cO cI cadd cmul csub copp ceqb cdiv lpe in Ring_polynom.Peq ceqb (Ring_polynom.norm_subst cO cI cadd cmul csub copp ceqb cdiv n lmp pe1) (Ring_polynom.norm_subst cO cI cadd cmul csub copp ceqb cdiv n lmp pe2)) = true -> req (Ring_polynom.PEeval rO rI radd rmul rsub ropp phi Cp_phi rpow l pe1) (Ring_polynom.PEeval rO rI radd rmul rsub ropp phi Cp_phi rpow l pe2)
ring_rw_correct: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall (Cpow : Type) (Cp_phi : BinNums.N -> Cpow) (rpow : R -> Cpow -> R), power_theory rI rmul req Cp_phi rpow -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall get_sign : C -> option C, sign_theory copp ceqb get_sign -> forall (n : nat) (lH : list (Ring_polynom.PExpr C * Ring_polynom.PExpr C)) (l : list R), Ring_polynom.interp_PElist rO rI radd rmul rsub ropp req phi Cp_phi rpow l lH -> forall lmp : list (C * Ring_polynom.Mon * Ring_polynom.Pol C), Ring_polynom.mk_monpol_list cO cI cadd cmul csub copp ceqb cdiv lH = lmp -> forall (pe : Ring_polynom.PExpr C) (npe : Ring_polynom.Pol C), Ring_polynom.norm_subst cO cI cadd cmul csub copp ceqb cdiv n lmp pe = npe -> req (Ring_polynom.PEeval rO rI radd rmul rsub ropp phi Cp_phi rpow l pe) (Ring_polynom.Pphi_dev rO rI radd rmul rsub ropp cO cI ceqb phi get_sign l npe)
ring_rw_pow_correct: forall [R : Type] [rO rI : R] [radd rmul rsub : R -> R -> R] [ropp : R -> R] [req : R -> R -> Prop], RelationClasses.Equivalence req -> ring_eq_ext radd rmul ropp req -> almost_ring_theory rO rI radd rmul rsub ropp req -> forall (C : Type) (cO cI : C) (cadd cmul csub : C -> C -> C) (copp : C -> C) (ceqb : C -> C -> bool) (phi : C -> R), ring_morph rO rI radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi -> forall (Cpow : Type) (Cp_phi : BinNums.N -> Cpow) (rpow : R -> Cpow -> R), power_theory rI rmul req Cp_phi rpow -> forall cdiv : C -> C -> C * C, div_theory req cadd cmul phi cdiv -> forall get_sign : C -> option C, sign_theory copp ceqb get_sign -> forall (n : nat) (lH : list (Ring_polynom.PExpr C * Ring_polynom.PExpr C)) (l : list R), Ring_polynom.interp_PElist rO rI radd rmul rsub ropp req phi Cp_phi rpow l lH -> forall lmp : list (C * Ring_polynom.Mon * Ring_polynom.Pol C), Ring_polynom.mk_monpol_list cO cI cadd cmul csub copp ceqb cdiv lH = lmp -> forall (pe : Ring_polynom.PExpr C) (npe : Ring_polynom.Pol C), Ring_polynom.norm_subst cO cI cadd cmul csub copp ceqb cdiv n lmp pe = npe -> req (Ring_polynom.PEeval rO rI radd rmul rsub ropp phi Cp_phi rpow l pe) (Ring_polynom.Pphi_pow rO rI radd rmul rsub ropp cO cI ceqb phi Cp_phi rpow get_sign l npe)
Rlt_wd: forall z : nat, Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff)) (fun n m : nat => z <= n < m)
rs'_rs'': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, z <= n -> (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n) -> forall n : nat, (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n <-> (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) (S n)
rs_rs': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, A z -> (forall n : nat, z <= n -> A n -> A (S n)) -> forall n : nat, z <= n -> (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n
S_pred: forall n m : nat, m < n -> n = S (Init.Nat.pred n)
S_pred_pos: forall n : nat, 0 < n -> n = S (Init.Nat.pred n)
seq_app: forall len1 len2 start : nat, List.seq start (len1 + len2) = (List.seq start len1 ++ List.seq (start + len1) len2)%list
seq_length: forall len start : nat, Datatypes.length (List.seq start len) = len
seq_NoDup: forall len start : nat, List.NoDup (List.seq start len)
seq_nth: forall [len : nat] (start : nat) [n : nat] (d : nat), n < len -> List.nth n (List.seq start len) d = start + n
seq_S: forall len start : nat, List.seq start (S len) = (List.seq start len ++ start + len :: Datatypes.nil)%list
seq_shift: forall len start : nat, List.map S (List.seq start len) = List.seq (S start) len
setbit_eq: forall a n : nat, Nat.testbit (Nat.setbit a n) n = true
setbit_eqb: forall a n m : nat, Nat.testbit (Nat.setbit a n) m = ((n =? m) || Nat.testbit a m)%bool
setbit_iff: forall a n m : nat, Nat.testbit (Nat.setbit a n) m = true <-> n = m \/ Nat.testbit a m = true
setbit_neq: forall a n m : nat, n <> m -> Nat.testbit (Nat.setbit a n) m = Nat.testbit a m
setbit_spec': forall a n : nat, Nat.setbit a n = Nat.lor a (2 ^ n)
shiftl: (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n
shiftl: (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n
shiftl_0_l: forall n : nat, Nat.shiftl 0 n = 0
shiftl_0_r: forall a : nat, Nat.shiftl a 0 = a
shiftl_1_l: forall n : nat, Nat.shiftl 1 n = 2 ^ n
shiftl_eq_0_iff: forall a n : nat, Nat.shiftl a n = 0 <-> a = 0
shiftl_land: forall a b n : nat, Nat.shiftl (Nat.land a b) n = Nat.land (Nat.shiftl a n) (Nat.shiftl b n)
shiftl_ldiff: forall a b n : nat, Nat.shiftl (Nat.ldiff a b) n = Nat.ldiff (Nat.shiftl a n) (Nat.shiftl b n)
shiftl_lor: forall a b n : nat, Nat.shiftl (Nat.lor a b) n = Nat.lor (Nat.shiftl a n) (Nat.shiftl b n)
shiftl_lxor: forall a b n : nat, Nat.shiftl (Nat.lxor a b) n = Nat.lxor (Nat.shiftl a n) (Nat.shiftl b n)
shiftl_mul_pow2: forall a n : nat, Nat.shiftl a n = a * 2 ^ n
shiftl_nat: BinNums.N -> forall n : nat, (fun _ : nat => BinNums.N) n
shiftl_nat: BinNums.N -> forall n : nat, (fun _ : nat => BinNums.N) n
shiftl_nat: BinNums.positive -> forall n : nat, (fun _ : nat => BinNums.positive) n
shiftl_nat: BinNums.positive -> forall n : nat, (fun _ : nat => BinNums.positive) n
shiftl_shiftl: forall a n m : nat, Nat.shiftl (Nat.shiftl a n) m = Nat.shiftl a (n + m)
shiftl_spec_alt: forall a n m : nat, Nat.testbit (Nat.shiftl a n) (m + n) = Nat.testbit a m
shiftl_spec_high': forall a n m : nat, n <= m -> Nat.testbit (Nat.shiftl a n) m = Nat.testbit a (m - n)
shiftl_spec_high: forall a n m : nat, 0 <= m -> n <= m -> Nat.testbit (Nat.shiftl a n) m = Nat.testbit a (m - n)
shiftl_spec_low: forall a n m : nat, m < n -> Nat.testbit (Nat.shiftl a n) m = false
shiftl_specif_high: forall a n m : nat, n <= m -> Nat.testbit (Nat.shiftl a n) m = Nat.testbit a (m - n)
shiftr: (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n
shiftr: (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n
shiftr_0_l: forall n : nat, Nat.shiftr 0 n = 0
shiftr_0_r: forall a : nat, Nat.shiftr a 0 = a
shiftr_div_pow2: forall a n : nat, Nat.shiftr a n = a / 2 ^ n
shiftr_eq_0: forall a n : nat, Nat.log2 a < n -> Nat.shiftr a n = 0
shiftr_eq_0_iff: forall a n : nat, Nat.shiftr a n = 0 <-> a = 0 \/ 0 < a /\ Nat.log2 a < n
shiftr_land: forall a b n : nat, Nat.shiftr (Nat.land a b) n = Nat.land (Nat.shiftr a n) (Nat.shiftr b n)
shiftr_ldiff: forall a b n : nat, Nat.shiftr (Nat.ldiff a b) n = Nat.ldiff (Nat.shiftr a n) (Nat.shiftr b n)
shiftr_lor: forall a b n : nat, Nat.shiftr (Nat.lor a b) n = Nat.lor (Nat.shiftr a n) (Nat.shiftr b n)
shiftr_lxor: forall a b n : nat, Nat.shiftr (Nat.lxor a b) n = Nat.lxor (Nat.shiftr a n) (Nat.shiftr b n)
shiftr_nat: BinNums.N -> forall n : nat, (fun _ : nat => BinNums.N) n
shiftr_nat: BinNums.N -> forall n : nat, (fun _ : nat => BinNums.N) n
shiftr_nat: BinNums.positive -> forall n : nat, (fun _ : nat => BinNums.positive) n
shiftr_nat: BinNums.positive -> forall n : nat, (fun _ : nat => BinNums.positive) n
shiftr_shiftl_l: forall a n m : nat, m <= n -> Nat.shiftr (Nat.shiftl a n) m = Nat.shiftl a (n - m)
shiftr_shiftl_r: forall a n m : nat, n <= m -> Nat.shiftr (Nat.shiftl a n) m = Nat.shiftr a (m - n)
shiftr_shiftr: forall a n m : nat, Nat.shiftr (Nat.shiftr a n) m = Nat.shiftr a (n + m)
shiftr_spec': forall a n m : nat, Nat.testbit (Nat.shiftr a n) m = Nat.testbit a (m + n)
shiftr_spec: forall a n m : nat, 0 <= m -> Nat.testbit (Nat.shiftr a n) m = Nat.testbit a (m + n)
shiftr_specif: forall a n m : nat, Nat.testbit (Nat.shiftr a n) m = Nat.testbit a (m + n)
skipn: forall [A : Type], nat -> list A -> list A
skipn_all2: forall [A : Type] [n : nat] (l : list A), Datatypes.length l <= n -> List.skipn n l = Datatypes.nil
skipn_app: forall [A : Type] (n : nat) (l1 l2 : list A), List.skipn n (l1 ++ l2) = (List.skipn n l1 ++ List.skipn (n - Datatypes.length l1) l2)%list
skipn_cons: forall [A : Type] (n : nat) (a : A) (l : list A), List.skipn (S n) (a :: l) = List.skipn n l
skipn_firstn_comm: forall [A : Type] (m n : nat) (l : list A), List.skipn m (List.firstn n l) = List.firstn (n - m) (List.skipn m l)
skipn_length: forall [A : Type] (n : nat) (l : list A), Datatypes.length (List.skipn n l) = Datatypes.length l - n
skipn_map: forall [A B : Type] (f : A -> B) (n : nat) (l : list A), List.skipn n (List.map f l) = List.map f (List.skipn n l)
skipn_nil: forall (A : Type) (n : nat), List.skipn n (Datatypes.nil : list A) = Datatypes.nil
skipn_rev: forall [A : Type] (x : nat) (l : list A), List.skipn x (List.rev l) = List.rev (List.firstn (Datatypes.length l - x) l)
split_length_l: forall [A B : Type] (l : list (A * B)), Datatypes.length (fst (List.split l)) = Datatypes.length l
split_length_r: forall [A B : Type] (l : list (A * B)), Datatypes.length (snd (List.split l)) = Datatypes.length l
split_nth: forall [A B : Type] (l : list (A * B)) (n : nat) (d : A * B), List.nth n l d = (List.nth n (fst (List.split l)) (fst d), List.nth n (snd (List.split l)) (snd d))
sqrt_add_le: forall a b : nat, Nat.sqrt (a + b) <= Nat.sqrt a + Nat.sqrt b
sqrt_iter_spec: forall k p q r : nat, q = p + p -> r <= q -> let s := Nat.sqrt_iter k p q r in s * s <= k + p * p + (q - r) < S s * S s
sqrt_le_lin: forall a : nat, Nat.sqrt a <= a
sqrt_le_mono: forall a b : nat, a <= b -> Nat.sqrt a <= Nat.sqrt b
sqrt_le_square: forall a b : nat, b * b <= a <-> b <= Nat.sqrt a
sqrt_lt_cancel: forall a b : nat, Nat.sqrt a < Nat.sqrt b -> a < b
sqrt_lt_lin: forall a : nat, 1 < a -> Nat.sqrt a < a
sqrt_lt_square: forall a b : nat, a < b * b <-> Nat.sqrt a < b
sqrt_mul_above: forall a b : nat, Nat.sqrt (a * b) < S (Nat.sqrt a) * S (Nat.sqrt b)
sqrt_mul_below: forall a b : nat, Nat.sqrt a * Nat.sqrt b <= Nat.sqrt (a * b)
sqrt_neg: forall a : nat, a < 0 -> Nat.sqrt a = 0
sqrt_spec': forall a : nat, Nat.sqrt a * Nat.sqrt a <= a < S (Nat.sqrt a) * S (Nat.sqrt a)
sqrt_spec: forall a : nat, 0 <= a -> Nat.sqrt a * Nat.sqrt a <= a < S (Nat.sqrt a) * S (Nat.sqrt a)
sqrt_specif: forall n : nat, Nat.sqrt n * Nat.sqrt n <= n < S (Nat.sqrt n) * S (Nat.sqrt n)
sqrt_sqrt_up_exact: forall a : nat, 0 <= a -> Nat.sqrt a = Nat.sqrt_up a <-> (exists b : nat, 0 <= b /\ a = b * b)
sqrt_sqrt_up_spec: forall a : nat, 0 <= a -> Nat.sqrt a * Nat.sqrt a <= a <= Nat.sqrt_up a * Nat.sqrt_up a
sqrt_square: forall a : nat, Nat.sqrt (a * a) = a
sqrt_succ_le: forall a : nat, Nat.sqrt (S a) <= S (Nat.sqrt a)
sqrt_succ_or: forall a : nat, Nat.sqrt (S a) = S (Nat.sqrt a) \/ Nat.sqrt (S a) = Nat.sqrt a
sqrt_unique: forall a b : nat, b * b <= a < S b * S b -> Nat.sqrt a = b
sqrt_up_add_le: forall a b : nat, Nat.sqrt_up (a + b) <= Nat.sqrt_up a + Nat.sqrt_up b
sqrt_up_eq_succ_iff_square: forall a : nat, 0 <= a -> Nat.sqrt_up (S a) = S (Nat.sqrt_up a) <-> (exists b : nat, 0 <= b /\ a = b * b)
sqrt_up_eqn: forall a : nat, 0 < a -> Nat.sqrt_up a = S (Nat.sqrt (Nat.pred a))
sqrt_up_eqn0: forall a : nat, a <= 0 -> Nat.sqrt_up a = 0
sqrt_up_le_lin: forall a : nat, 0 <= a -> Nat.sqrt_up a <= a
sqrt_up_le_mono: forall a b : nat, a <= b -> Nat.sqrt_up a <= Nat.sqrt_up b
sqrt_up_le_square: forall a b : nat, 0 <= a -> 0 <= b -> a <= b * b <-> Nat.sqrt_up a <= b
sqrt_up_lt_cancel: forall a b : nat, Nat.sqrt_up a < Nat.sqrt_up b -> a < b
sqrt_up_lt_lin: forall a : nat, 2 < a -> Nat.sqrt_up a < a
sqrt_up_lt_square: forall a b : nat, 0 <= a -> 0 <= b -> b * b < a <-> b < Nat.sqrt_up a
sqrt_up_mul_above: forall a b : nat, 0 <= a -> 0 <= b -> Nat.sqrt_up (a * b) <= Nat.sqrt_up a * Nat.sqrt_up b
sqrt_up_mul_below: forall a b : nat, 0 < a -> 0 < b -> Nat.pred (Nat.sqrt_up a) * Nat.pred (Nat.sqrt_up b) < Nat.sqrt_up (a * b)
sqrt_up_nonneg: forall a : nat, 0 <= Nat.sqrt_up a
sqrt_up_pos: forall a : nat, 0 < Nat.sqrt_up a <-> 0 < a
sqrt_up_spec: forall a : nat, 0 < a -> Nat.pred (Nat.sqrt_up a) * Nat.pred (Nat.sqrt_up a) < a <= Nat.sqrt_up a * Nat.sqrt_up a
sqrt_up_square: forall a : nat, 0 <= a -> Nat.sqrt_up (a * a) = a
sqrt_up_succ_le: forall a : nat, 0 <= a -> Nat.sqrt_up (S a) <= S (Nat.sqrt_up a)
sqrt_up_succ_or: forall a : nat, 0 <= a -> Nat.sqrt_up (S a) = S (Nat.sqrt_up a) \/ Nat.sqrt_up (S a) = Nat.sqrt_up a
sqrt_up_succ_square: forall a : nat, 0 <= a -> Nat.sqrt_up (S (a * a)) = S a
sqrt_up_unique: forall a b : nat, 0 < b -> Nat.pred b * Nat.pred b < a <= b * b -> Nat.sqrt_up a = b
square_add_le: forall a b : nat, 0 <= a -> 0 <= b -> (a + b) * (a + b) <= 2 * (a * a + b * b)
square_le_mono: forall n m : nat, n <= m <-> n * n <= m * m
square_le_mono_nonneg: forall n m : nat, 0 <= n -> n <= m -> n * n <= m * m
square_le_simpl_nonneg: forall n m : nat, 0 <= m -> n * n <= m * m -> n <= m
square_lt_mono: forall n m : nat, n < m <-> n * n < m * m
square_lt_mono_nonneg: forall n m : nat, 0 <= n -> n < m -> n * n < m * m
square_lt_simpl_nonneg: forall n m : nat, 0 <= m -> n * n < m * m -> n < m
square_nonneg: forall a : nat, 0 <= a * a
square_spec: forall n : nat, Nat.square n = n * n
strong_left_induction': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, z <= n -> A n) -> (forall n : nat, n <= z -> (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) (S n) -> A n) -> forall n : nat, A n
strong_left_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, n <= z -> (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) (S n) -> A n) -> forall n : nat, n <= z -> A n
strong_right_induction': forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, n <= z -> A n) -> (forall n : nat, z <= n -> (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n) -> forall n : nat, A n
strong_right_induction: forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> forall z : nat, (forall n : nat, z <= n -> (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n) -> forall n : nat, z <= n -> A n
sub_0_l: forall n : nat, 0 - n = 0
sub_0_le: forall n m : nat, n - m = 0 <-> n <= m
sub_0_r: forall n : nat, n - 0 = n
sub_1_r: forall n : nat, n - 1 = Nat.pred n
sub_add: forall n m : nat, n <= m -> m - n + n = m
sub_add_distr: forall n m p : nat, n - (m + p) = n - m - p
sub_add_le: forall n m : nat, n <= n - m + m
sub_diag: forall n : nat, n - n = 0
sub_gt: forall n m : nat, m < n -> n - m <> 0
sub_le_mono_l: forall n m p : nat, n <= m -> p - m <= p - n
sub_le_mono_r: forall n m p : nat, n <= m -> n - p <= m - p
sub_lt: forall n m : nat, m <= n -> 0 < m -> n - m < n
sub_max_distr_l: forall n m p : nat, Nat.max (p - n) (p - m) = p - Nat.min n m
sub_max_distr_r: forall n m p : nat, Nat.max (n - p) (m - p) = Nat.max n m - p
sub_min_distr_l: forall n m p : nat, Nat.min (p - n) (p - m) = p - Nat.max n m
sub_min_distr_r: forall n m p : nat, Nat.min (n - p) (m - p) = Nat.min n m - p
sub_nocarry_ldiff: forall a b : nat, Nat.ldiff b a = 0 -> a - b = Nat.ldiff a b
sub_succ: forall n m : nat, S n - S m = n - m
sub_succ_l: forall n m : nat, n <= m -> S m - n = S (m - n)
sub_succ_r: forall n m : nat, n - S m = Nat.pred (n - m)
succ_add_discr: forall n m : nat, m <> S (n + m)
succ_inj: forall n1 n2 : nat, S n1 = S n2 -> n1 = n2
succ_inj_wd: forall n1 n2 : nat, S n1 = S n2 <-> n1 = n2
succ_inj_wd_neg: forall n m : nat, S n <> S m <-> n <> m
succ_le_mono: forall n m : nat, n <= m <-> S n <= S m
succ_lt_mono: forall n m : nat, n < m <-> S n < S m
succ_max_distr: forall n m : nat, S (Nat.max n m) = Nat.max (S n) (S m)
succ_min_distr: forall n m : nat, S (Nat.min n m) = Nat.min (S n) (S m)
succ_of_nat: forall n : nat, n <> 0 -> BinPos.Pos.succ (BinPos.Pos.of_nat n) = BinPos.Pos.of_succ_nat n
succ_plus_discr: forall n m : nat, n <> S (m + n)
succ_pred: forall n : nat, n <> 0 -> S (Nat.pred n) = n
succ_pred_pos: forall n : nat, 0 < n -> S (Nat.pred n) = n
tail_add_spec: forall n m : nat, Nat.tail_add n m = n + m
tail_addmul_spec: forall r n m : nat, Nat.tail_addmul r n m = r + n * m
tail_mul_spec: forall n m : nat, Nat.tail_mul n m = n * m
testbit_0_l: forall n : nat, Nat.testbit 0 n = false
testbit_0_r: forall (a : nat) (b : bool), Nat.testbit (2 * a + Nat.b2n b) 0 = b
testbit_bitwise_1: forall op : bool -> bool -> bool, (forall b : bool, op false b = false) -> forall n m a b : nat, a <= n -> Nat.testbit (Nat.bitwise op n a b) m = op (Nat.testbit a m) (Nat.testbit b m)
testbit_bitwise_2: forall op : bool -> bool -> bool, op false false = false -> forall n m a b : nat, a <= n -> b <= n -> Nat.testbit (Nat.bitwise op n a b) m = op (Nat.testbit a m) (Nat.testbit b m)
testbit_eqb: forall a n : nat, Nat.testbit a n = ((a / 2 ^ n) mod 2 =? 1)
testbit_even_0: forall a : nat, Nat.testbit (2 * a) 0 = false
testbit_even_succ': forall a n : nat, Nat.testbit (2 * a) (S n) = Nat.testbit a n
testbit_even_succ: forall a n : nat, 0 <= n -> Nat.testbit (2 * a) (S n) = Nat.testbit a n
testbit_false: forall a n : nat, Nat.testbit a n = false <-> (a / 2 ^ n) mod 2 = 0
testbit_neg_r: forall a n : nat, n < 0 -> Nat.testbit a n = false
testbit_odd: forall a n : nat, Nat.testbit a n = Nat.odd (Nat.shiftr a n)
testbit_odd_0: forall a : nat, Nat.testbit (2 * a + 1) 0 = true
testbit_odd_succ': forall a n : nat, Nat.testbit (2 * a + 1) (S n) = Nat.testbit a n
testbit_odd_succ: forall a n : nat, 0 <= n -> Nat.testbit (2 * a + 1) (S n) = Nat.testbit a n
testbit_spec': forall a n : nat, Nat.b2n (Nat.testbit a n) = (a / 2 ^ n) mod 2
testbit_spec: forall a n : nat, exists l h : nat, 0 <= l < 2 ^ n /\ a = l + (Nat.b2n (Nat.testbit a n) + 2 * h) * 2 ^ n
testbit_succ_r: forall (a : nat) (b : bool) (n : nat), Nat.testbit (2 * a + Nat.b2n b) (S n) = Nat.testbit a n
testbit_true: forall a n : nat, Nat.testbit a n = true <-> (a / 2 ^ n) mod 2 = 1
testbit_unique: forall (a n : nat) (a0 : bool) (l h : nat), l < 2 ^ n -> a = l + (Nat.b2n a0 + 2 * h) * 2 ^ n -> Nat.testbit a n = a0
two_dim_induction: forall R : nat -> nat -> Prop, Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff)) R -> R 0 0 -> (forall n m : nat, R n m -> R n (S m)) -> (forall n : nat, (forall m : nat, R n m) -> R (S n) 0) -> forall n m : nat, R n m
UIP_nat: forall (x y : nat) (p1 p2 : x = y), p1 = p2
UIP_refl_nat: forall (n : nat) (x : n = n), x = eq_refl
well_founded_gtof: forall (A : Type) (f : A -> nat), well_founded (gtof A f)
well_founded_inv_lt_rel_compat: forall (A : Set) (R : A -> A -> Prop) (F : A -> nat -> Prop), (forall x y : A, R x y -> inv_lt_rel A F x y) -> well_founded R
well_founded_inv_rel_inv_lt_rel: forall (A : Set) (F : A -> nat -> Prop), well_founded (inv_lt_rel A F)
well_founded_lt_compat: forall (A : Type) (f : A -> nat) (R : A -> A -> Prop), (forall x y : A, R x y -> f x < f y) -> well_founded R
well_founded_ltof: forall (A : Type) (f : A -> nat), well_founded (ltof A f)

zerop: forall n : nat, {n = 0} + {0 < n}
ZL6: forall p : BinNums.positive, BinPos.Pos.iter_op Init.Nat.add p 2 = BinPos.Pos.to_nat p + BinPos.Pos.to_nat p
Zle_0_nat: forall n : nat, BinInt.Z.le BinNums.Z0 (BinInt.Z.of_nat n)
*)
